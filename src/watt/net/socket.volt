// See copyright notice in src/watt/licence.volt (BOOST ver 1.0).
/*
		Copyright (C) 2004-2011 Christopher E. Miller

		Boost Software License - Version 1.0 - August 17th, 2003

		Permission is hereby granted, free of charge, to any person or organization
		obtaining a copy of the software and accompanying documentation covered by
		this license (the "Software") to use, reproduce, display, distribute,
		execute, and transmit the Software, and to prepare derivative works of the
		Software, and to permit third-parties to whom the Software is furnished to
		do so, all subject to the following:

		The copyright notices in the Software and this entire statement, including
		the above license grant, this restriction and the following disclaimer,
		must be included in all copies of the Software, in whole or in part, and
		all derivative works of the Software, unless such copies or derivative
		works are solely in the form of machine-executable object code generated by
		a source language processor.

		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
		SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
		FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
		ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
		DEALINGS IN THE SOFTWARE.

		socket.d 1.4
		Jan 2011

		Thanks to Benjamin Herr for his assistance.
 */
module watt.net.socket;

version (Windows)
{
	import core.c.windows.winsock2;

	enum socket_t : SOCKET { INVALID_SOCKET }
	private enum _SOCKET_ERROR = SOCKET_ERROR;

	public fn _lasterr() i32
	{
		return WSAGetLastError();
	}

	alias l_onoff_t = u16;
	alias l_linger_t = u16;
	alias in_addr_t = u32;
	alias tv_sec_t = i32;
	alias tv_usec_t = i32;
}
else
{
	import core.c.posix.sys.socket;
	import core.c.posix.sys.un;
	import core.c.posix.sys.time;
	import core.c.posix.netinet.in_;
	import core.c.posix.netinet.tcp;
	import core.c.posix.netdb;
	import core.c.posix.fcntl;
	import core.c.posix.unistd;

	private enum
	{
		SD_RECEIVE = SHUT_RD,
		SD_SEND    = SHUT_WR,
		SD_BOTH    = SHUT_RDWR
	}

	enum socket_t { init = -1 }
	private enum _SOCKET_ERROR = -1;

	private local extern extern(C) errno: i32;
	private enum EINPROGRESS = 115;

	private fn _lasterr() i32
	{
		return errno;
	}

	alias l_onoff_t = i32;
	alias l_linger_t = i32;
}

global this()
{
	version (Windows) {
		wd: WSADATA;

		// Winsock will still load if an older version is present.
		// The version is just a request.
		val: i32 = WSAStartup(0x2020, &wd);
		if (val) {        // Request Winsock 2.2 for IPv6.
			throw new SocketOSException("Unable to initialize socket library", val);
		}
	}
}

import core.object;
import core.exception;
import core.c.string;
import watt.conv;
import watt.text.format;
import watt.text.string;

import core.exception : Exception;

class SocketException : Exception
{
	this(msg: string)
	{
		super(msg);
	}
}

class SocketOSException : SocketException
{
	error: i32;

	this(msg: string)
	{
		error = _lasterr();
		super(msg);
	}

	this(msg: string, error: i32)
	{
		this.error = error;
		super(msg);
	}
}

class HostException : SocketOSException
{
	this(msg: string)
	{
		super(msg);
	}
}

class AddressException : SocketOSException
{
	this(msg: string)
	{
		super(msg);
	}
}

class SocketAcceptException : SocketOSException
{
	this(msg: string)
	{
		super(msg);
	}
}

/**
 * The communication domain used to resolve an address.
 */
enum AddressFamily
{
	UNSPEC =     AF_UNSPEC,     //< Unspecified address family
	UNIX =       AF_UNIX,       //< Local communication
	INET =       AF_INET,       //< Internet Protocol version 4
	IPX =        AF_IPX,        //< Novell IPX
	APPLETALK =  AF_APPLETALK,  //< AppleTalk
	INET6 =      AF_INET6,      //< Internet Protocol version 6
}

/**
 * Communication semantics
 */
enum SocketType
{
	STREAM =     SOCK_STREAM,           //< Sequenced, reliable, two-way communication-based byte streams
	DGRAM =      SOCK_DGRAM,            //< Connectionless, unreliable datagrams with a fixed maximum length; data may be lost or arrive out of order
	RAW =        SOCK_RAW,              //< Raw protocol access
	RDM =        SOCK_RDM,              //< Reliably-delivered message datagrams
	SEQPACKET =  SOCK_SEQPACKET,        //< Sequenced, reliable, two-way connection-based datagrams with a fixed maximum length
}

/**
 * Protocol
 */
enum ProtocolType
{
	IP =    IPPROTO_IP,         //< Internet Protocol version 4
	ICMP =  IPPROTO_ICMP,       //< Internet Control Message Protocol
	IGMP =  IPPROTO_IGMP,       //< Internet Group Management Protocol
	GGP =   IPPROTO_GGP,        //< Gateway to Gateway Protocol
	TCP =   IPPROTO_TCP,        //< Transmission Control Protocol
	PUP =   IPPROTO_PUP,        //< PARC Universal Packet Protocol
	UDP =   IPPROTO_UDP,        //< User Datagram Protocol
	IDP =   IPPROTO_IDP,        //< Xerox NS protocol
	RAW =   IPPROTO_RAW,        //< Raw IP packets
	IPV6 =  IPPROTO_IPV6,       //< Internet Protocol version 6
}

/**
 * $(D Protocol) is a class for retrieving protocol information.
 *
 * Example:
 * ---
 * auto proto = new Protocol;
 * writeln("About protocol TCP:");
 * if (proto.getProtocolByType(ProtocolType.TCP))
 * {
 *     writefln("  Name: %s", proto.name);
 *     foreach (string s; proto.aliases)
 *          writefln("  Alias: %s", s);
 * }
 * else
 *     writeln("  No information found");
 * ---
 */
class Protocol
{
	/// These members are populated when one of the following functions are called successfully:
	type: ProtocolType;
	name: string;                /// ditto
	aliases: string[];           /// ditto

	fn populate(proto: protoent*)
	{
		type = cast(ProtocolType)proto.p_proto;
		name = .toString(proto.p_name);

		i: i32;
		for (i = 0;; i++) {
			if (proto.p_aliases[i] is null) {
				break;
			}
		}

		if (i) {
			aliases = new string[](i);
			for (i = 0; i != cast(i32)aliases.length; i++)
			{
				aliases[i] = .toString(proto.p_aliases[i]);
			}
		} else {
			aliases = null;
		}
	}

	/** Returns: false on failure */
	fn getProtocolByName(name: const(char)[]) bool
	{
		proto: protoent*;
		proto = getprotobyname(toStringz(name));
		if (proto is null) {
			return false;
		}
		populate(proto);
		return true;
	}

	/** Returns: false on failure */
	// Same as getprotobynumber().
	fn getProtocolByType(type: ProtocolType) bool
	{
		proto: protoent*;
		proto = getprotobynumber(type);
		if (proto is null) {
			return false;
		}
		populate(proto);
		return true;
	}
}

/**
 * $(D Service) is a class for retrieving service information.
 *
 * Example:
 * ---
 * auto serv = new Service;
 * writeln("About service epmap:");
 * if (serv.getServiceByName("epmap", "tcp"))
 * {
 *     writefln("  Service: %s", serv.name);
 *     writefln("  Port: %d", serv.port);
 *     writefln("  Protocol: %s", serv.protocolName);
 *     foreach (string s; serv.aliases)
 *          writefln("  Alias: %s", s);
 * }
 * else
 *     writefln("  No service for epmap.");
 * ---
 */
class Service
{
	/// These members are populated when one of the following functions are called successfully:
	name: string;
	aliases: string[];
	port: u16;
	protocolName: string;


	fn populate(serv: servent*)
	{
		name = .toString(serv.s_name);
		port = ntohs(cast(u16)(serv.s_port));
		protocolName = .toString(serv.s_proto);

		i: i32;
		for (i = 0;; i++)
		{
			if (serv.s_aliases[i] is null) {
				break;
			}
		}

		if (i) {
			aliases = new string[](i);
			for (i = 0; i != cast(i32)aliases.length; i++)
			{
				aliases[i] = .toString(serv.s_aliases[i]);
			}
		} else {
			aliases = null;
		}
	}

	/**
	 * If a protocol name is omitted, any protocol will be matched.
	 * Returns: false on failure.
	 */
	fn getServiceByName(name: const(char)[], protocolName: const(char)[] = null) bool
	{
		serv: servent*;
		serv = getservbyname(toStringz(name), toStringz(protocolName));
		if (serv is null) {
			return false;
		}
		populate(serv);
		return true;
	}


	/**
	 * If a protocol name is omitted, any protocol will be matched.
	 * Returns: false on failure.
	 */
	fn getServiceByPort(port: u16, protocolName: const(char)[] = null) bool
	{
		serv: servent*;
		serv = getservbyport(port, toStringz(protocolName));
		if (serv is null) {
			return false;
		}
		populate(serv);
		return true;
	}
}

/**
 * `InternetHost` is a class for resolving IPv4 addresses.
 *
 * Consider using `getAddress`, `parseAddress` and `Address` methods
 * instead of using this class directly.
 */
class InternetHost
{
	/// These members are populated when one of the following functions are called successfully:
	name: string;
	aliases: string[];
	addrList: u32[];

	fn validHostent(he: const(hostent)*)
	{
		if (he.h_addrtype != cast(i32)AddressFamily.INET || he.h_length != 4) {
			throw new HostException("Address family mismatch");
		}
	}

	fn populate(he: hostent*)
	{
		i: i32;
		p: char*;

		name = .toString(he.h_name);

		for (i = 0;; i++) {
			p = he.h_aliases[i];
			if (p is null) {
				break;
			}
		}

		if (i) {
			aliases = new string[](i);
			for (i = 0; i != cast(i32)aliases.length; i++) {
				aliases[i] = .toString(he.h_aliases[i]);
			}
		} else {
			aliases = null;
		}

		for (i = 0;; i++) {
			p = he.h_addr_list[i];
			if (p is null) {
				break;
			}
		}

		if (i) {
			addrList = new u32[](i);
			for (i = 0; i != cast(i32)addrList.length; i++) {
				addrList[i] = ntohl(*(cast(u32*)he.h_addr_list[i]));
			}
		} else {
			addrList = null;
		}
	}

	/**
	 * Resolve host name.
	 * Returns: false if unable to resolve.
	 */
	fn getHostByName(name: const(char)[]) bool
	{
		he := gethostbyname(toStringz(name));
		if (he is null) {
			return false;
		}
		validHostent(he);
		populate(he);
		return true;
	}

	/**
	 * Resolve IPv4 address number.
	 *
	 * Params:
	 *   addr = The IPv4 address to resolve, in host byte order.
	 * Returns:
	 *   false if unable to resolve.
	 */
	fn getHostByAddr(addr: u32) bool
	{
		x := htonl(addr);
		he := gethostbyaddr(cast(void*)&x, 4, cast(i32)AddressFamily.INET);
		if (he is null) {
			return false;
		}
		validHostent(he);
		populate(he);
		return true;
	}

	/**
	 * Same as previous, but addr is an IPv4 address string in the
	 * dotted-decimal form $(I a.b.c.d).
	 * Returns: false if unable to resolve.
	 */
	fn getHostByAddr(addr: const(char)[]) bool
	{
		x := inet_addr(toStringz(addr));
		if (x == INADDR_NONE) {
			throw new SocketException("Invalid IPV4 address");
		}
		he := gethostbyaddr(cast(void*)&x, 4, cast(i32)AddressFamily.INET);
		if (he is null) {
			return false;
		}
		validHostent(he);
		populate(he);
		return true;
	}
}

struct AddressInfo
{
	family: AddressFamily;   //< Address _family
	type: SocketType;        //< Socket _type
	protocol: ProtocolType;  //< Protocol
	address: Address;        //< Socket _address
	canonicalName: string;   //< Canonical name, when $(D AddressInfoFlags.CANONNAME) is used.
}

// A subset of flags supported on all platforms with getaddrinfo.
/// Specifies option flags for $(D getAddressInfo).
enum AddressInfoFlags: i32
{
	/// The resulting addresses will be used in a call to $(D Socket.bind).
	PASSIVE = AI_PASSIVE,

	/// The canonical name is returned in $(D canonicalName) member in the first $(D AddressInfo).
	CANONNAME = AI_CANONNAME,

	/// The $(D node) parameter passed to $(D getAddressInfo) must be a numeric string.
	/// This will suppress any potentially lengthy network host address lookups.
	NUMERICHOST = AI_NUMERICHOST,
}

struct AddressInfoSearcher
{
private:
	hints: addrinfo;
	service: const(char)[];

public:
	fn addHint(s: const(char)[])
	{
		service = s;
	}

	fn addHint(f: AddressInfoFlags)
	{
		hints.ai_flags |= f;
	}

	fn addHint(f: AddressFamily)
	{
		hints.ai_family = f;
	}

	fn addHint(f: SocketType)
	{
		hints.ai_socktype = f;
	}

	fn addHint(f: ProtocolType)
	{
		hints.ai_protocol = f;
	}

	/**
	* Provides _protocol-independent translation from host names to socket
	* addresses. If advanced functionality is not required, consider using
	* $(D getAddress) for compatibility with older systems.
	*
	* Returns: Array with one $(D AddressInfo) per socket address.
	*
	* Throws: $(D SocketOSException) on failure, or $(D SocketFeatureException)
	* if this functionality is not available on the current system.
	*/
	fn get(node: const(char)[]) AddressInfo[]
	{
		ai_res: addrinfo*;

		if (node is null && service is null) {
			throw new SocketException("cannot search with null node AND null service");
		}

		ret: i32 = getaddrinfo(
			node is null ? null : toStringz(node),
			service is null ? null : toStringz(service),
			&hints, &ai_res);
		if (ret != 0) {
			throw new SocketOSException("getaddrinfo error");
		}
		scope(exit) freeaddrinfo(ai_res);

		result: AddressInfo[];

		for (const(addrinfo)* ai = ai_res; ai; ai = ai.ai_next) {
			newAI: AddressInfo;
			newAI.family = cast(AddressFamily)ai.ai_family;
			newAI.type = cast(SocketType)ai.ai_socktype;
			newAI.protocol = cast(ProtocolType)ai.ai_protocol;
			newAI.address = new UnknownAddressReference(ai.ai_addr, cast(socklen_t)ai.ai_addrlen);
			newAI.canonicalName = ai.ai_canonname !is null ? toString(ai.ai_canonname) : null;
			result ~= newAI;
		}

		assert(result.length > 0);
		return result;
	}
}



private fn serviceToPort(service: const(char)[]) u16
{
	if (service.length == 0) {
		return InternetAddress.PORT_ANY;
	} else {
		if (isNumeric(service)) {
			return toUshort(service);
		} else {
			s := new Service();
			s.getServiceByName(service);
			return s.port;
		}
	}
}

/**
 * Provides _protocol-independent translation from host names to socket
 * addresses. Uses $(D getAddressInfo) if the current system supports it,
 * and $(D InternetHost) otherwise.
 *
 * Returns: Array with one $(D Address) instance per socket address.
 *
 * Throws: $(D SocketOSException) on failure.
 *
 * Example:
 * ---
 * writeln("Resolving www.digitalmars.com:");
 * try
 * {
 *     auto addresses = getAddress("www.digitalmars.com");
 *     foreach (address; addresses)
 *         writefln("  IP: %s", address.toAddrString());
 * }
 * catch (SocketException e)
 *     writefln("  Lookup failed: %s", e.msg);
 * ---
 */
fn getAddress(hostname: const(char)[], service: const(char)[] = null) Address[]
{
	return getAddress(hostname, serviceToPort(service));
}

/// ditto
fn getAddress(hostname: const(char)[], port: u16) Address[]
{
	// use getHostByName
	ih := new InternetHost();
	if (!ih.getHostByName(hostname)) {
		throw new AddressException(
					format("Unable to resolve host '%s'", hostname));
	}

	results: Address[];
	foreach (addr; ih.addrList) {
		results ~= new InternetAddress(addr, port);
	}
	return results;
}

/**
 * Provides _protocol-independent parsing of network addresses. Does not
 * attempt name resolution. Uses $(D getAddressInfo) with
 * $(D AddressInfoFlags.NUMERICHOST) if the current system supports it, and
 * $(D InternetAddress) otherwise.
 *
 * Returns: An $(D Address) instance representing specified address.
 *
 * Throws: $(D SocketException) on failure.
 *
 * Example:
 * ---
 * writeln("Enter IP address:");
 * string ip = readln().chomp();
 * try
 * {
 *     Address address = parseAddress(ip);
 *     writefln("Looking up reverse of %s:",
 *         address.toAddrString());
 *     try
 *     {
 *         string reverse = address.toHostNameString();
 *         if (reverse)
 *             writefln("  Reverse name: %s", reverse);
 *         else
 *             writeln("  Reverse hostname not found.");
 *     }
 *     catch (SocketException e)
 *         writefln("  Lookup error: %s", e.msg);
 * }
 * catch (SocketException e)
 * {
 *     writefln("  %s is not a valid IP address: %s",
 *         ip, e.msg);
 * }
 * ---
 */
fn parseAddress(hostaddr: const(char)[], service: const(char)[] = null) Address
{
	return parseAddress(hostaddr, serviceToPort(service));
}

/// ditto
fn parseAddress(hostaddr: const(char)[], port: u16) Address
{
	in4_addr := InternetAddress.parse(hostaddr);
	if (in4_addr == InternetAddress.ADDR_NONE) {
		throw new SocketException("Invalid IP address");
	}
	return new InternetAddress(in4_addr, port);
}   

/**
 * $(D Address) is an abstract class for representing a socket addresses.
 *
 * Example:
 * ---
 * writeln("About www.google.com port 80:");
 * try
 * {
 *     Address[] addresses = getAddress("www.google.com", 80);
 *     writefln("  %d addresses found.", addresses.length);
 *     foreach (int i, Address a; addresses)
 *     {
 *         writefln("  Address %d:", i+1);
 *         writefln("    IP address: %s", a.toAddrString());
 *         writefln("    Hostname: %s", a.toHostNameString());
 *         writefln("    Port: %s", a.toPortString());
 *         writefln("    Service name: %s",
 *             a.toServiceNameString());
 *     }
 * }
 * catch (SocketException e)
 *     writefln("  Lookup error: %s", e.msg);
 * ---
 */
abstract class Address
{
	/// Returns pointer to underlying $(D sockaddr) structure.
	abstract @property fn name() sockaddr*;

	/// Returns actual size of underlying $(D sockaddr) structure.
	abstract @property fn nameLen() socklen_t;

	/// Family of this address.
	@property fn addressFamily() AddressFamily
	{
		return cast(AddressFamily) name.sa_family;
	}

	// Common code for toAddrString and toHostNameString
	private fn toHostString(numeric: bool) string
	{
		buf := new char[](NI_MAXHOST);
		ret := getnameinfo(
					name, nameLen,
					buf.ptr, cast(u32)buf.length,
					null, 0,
					numeric ? NI_NUMERICHOST : NI_NAMEREQD);

		if (!numeric) {
			if (ret==EAI_NONAME) {
				return null;
			}
			version(Windows) {
				if (ret==WSANO_DATA) {
					return null;
				}
			}
		}

		if (ret != 0) {
			throw new AddressException(format("%s Could not get host %s", ret,
				numeric ? "address" : "name"));
		}
		return cast(string)buf[0 .. strlen(buf.ptr)];
	}

	// Common code for toPortString and toServiceNameString
	private fn toServiceString(numeric: bool) string
	{
		buf := new char[](NI_MAXSERV);
		if (getnameinfo(
					name, nameLen,
					null, 0,
					buf.ptr, cast(u32)buf.length,
					numeric ? NI_NUMERICSERV : NI_NAMEREQD
				) != 0) {
					throw new AddressException("Could not get " ~
						(numeric ? "port number" : "service name"));
				}
		return cast(string)buf[0 .. strlen(buf.ptr)];
	}

	/**
	 * Attempts to retrieve the host address as a human-readable string.
	 *
	 * Throws: $(D AddressException) on failure, or $(D SocketFeatureException)
	 * if address retrieval for this address family is not available on the
	 * current system.
	 */
	fn toAddrString() string
	{
		return toHostString(true);
	}

	/**
	 * Attempts to retrieve the host name as a fully qualified domain name.
	 *
	 * Returns: The FQDN corresponding to this $(D Address), or $(D null) if
	 * the host name did not resolve.
	 *
	 * Throws: $(D AddressException) on error, or $(D SocketFeatureException)
	 * if host name lookup for this address family is not available on the
	 * current system.
	 */
	fn toHostNameString() string
	{
		return toHostString(false);
	}

	/**
	 * Attempts to retrieve the numeric port number as a string.
	 *
	 * Throws: $(D AddressException) on failure, or $(D SocketFeatureException)
	 * if port number retrieval for this address family is not available on the
	 * current system.
	 */
	fn toPortString() string
	{
		return toServiceString(true);
	}

	/**
	 * Attempts to retrieve the service name as a string.
	 *
	 * Throws: $(D AddressException) on failure, or $(D SocketFeatureException)
	 * if service name lookup for this address family is not available on the
	 * current system.
	 */
	fn toServiceNameString() string
	{
		return toServiceString(false);
	}

	/// Human readable string representing this address.
	override fn toString() string
	{
		try
		{
			host := toAddrString();
			port := toPortString();
			if (host.indexOf(':') >= 0) {
				return "[" ~ host ~ "]:" ~ port;
			} else {
				return host ~ ":" ~ port;
			}
		} catch (SocketException) {
			return "Unknown";
		}
		assert(false);
	}
}

/**
 * $(D UnknownAddress) encapsulates an unknown socket address.
 */
class UnknownAddress: Address
{
protected:
	sa: sockaddr;

public:
	override @property fn name() sockaddr*
	{
		return &sa;
	}

	override @property fn nameLen() socklen_t
	{
		return cast(socklen_t) typeid(sa).size;
	}
}


/**
 * $(D UnknownAddressReference) encapsulates a reference to an arbitrary
 * socket address.
 */
class UnknownAddressReference: Address
{
protected:
	sa: sockaddr*;
	len: socklen_t;

public:
	/// Constructs an $(D Address) with a reference to the specified $(D sockaddr).
	this(sa: sockaddr*, len: socklen_t)
	{
		this.sa  = sa;
		this.len = len;
	}

	/// Constructs an $(D Address) with a copy of the specified $(D sockaddr).
	this(sa: const(sockaddr)*, len: socklen_t)
	{
		buf := new sockaddr[](cast(size_t)len);
		memcpy(cast(void*)buf.ptr, cast(void*)sa, cast(size_t)len);
		this.sa = buf.ptr;
		this.len = len;
	}

	override @property fn name() sockaddr*
	{
		return sa;
	}

	override @property fn nameLen() socklen_t
	{
		return cast(socklen_t) len;
	}
}

/**
 * $(D InternetAddress) encapsulates an IPv4 (Internet Protocol version 4)
 * socket address.
 *
 * Consider using $(D getAddress), $(D parseAddress) and $(D Address) methods
 * instead of using this class directly.
 */
class InternetAddress: Address
{
protected:
	sin: sockaddr_in;

public:
	this()
	{
	}

	override @property fn name() sockaddr*
	{
		return cast(sockaddr*)&sin;
	}

	override @property fn nameLen() socklen_t
	{
		return cast(socklen_t) typeid(sin).size;
	}


	enum in_addr_t ADDR_ANY = INADDR_ANY;         /// Any IPv4 host address.
	enum in_addr_t ADDR_NONE = INADDR_NONE;       /// An invalid IPv4 host address.
	enum u16 PORT_ANY = 0;                /// Any IPv4 port number.

	/// Returns the IPv4 _port number (in host byte order).
	@property fn port() u16
	{
		return ntohs(sin.sin_port);
	}

	/// Returns the IPv4 address number (in host byte order).
	@property fn addr() u32
	{
		return ntohl(sin.sin_addr.s_addr);
	}

	/**
	 * Construct a new $(D InternetAddress).
	 * Params:
	 *   addr = an IPv4 address string in the dotted-decimal form a.b.c.d,
	 *          or a host name which will be resolved using an $(D InternetHost)
	 *          object.
	 *   port = port number, may be $(D PORT_ANY).
	 */
	this(addr: const(char)[], port: u16)
	{
		uiaddr: u32 = parse(addr);
		if (ADDR_NONE == uiaddr) {
			ih := new InternetHost;
			if (!ih.getHostByName(addr)) {
				throw new AddressException(format("Unable to resolve host '%s'", addr));
			}
			uiaddr = ih.addrList[0];
		}
		sin.sin_family = AddressFamily.INET;
		sin.sin_addr.s_addr = htonl(uiaddr);
		sin.sin_port = htons(port);
	}

	/**
	 * Construct a new $(D InternetAddress).
	 * Params:
	 *   addr = (optional) an IPv4 address in host byte order, may be $(D ADDR_ANY).
	 *   port = port number, may be $(D PORT_ANY).
	 */
	this(addr: u32, port: u16)
	{
		sin.sin_family = AddressFamily.INET;
		sin.sin_addr.s_addr = htonl(addr);
		sin.sin_port = htons(port);
	}

	/// ditto
	this(port: u16)
	{
		sin.sin_family = AddressFamily.INET;
		sin.sin_addr.s_addr = ADDR_ANY;
		sin.sin_port = htons(port);
	}

	/**
	 * Construct a new $(D InternetAddress).
	 * Params:
	 *   addr = A sockaddr_in as obtained from lower-level API calls such as getifaddrs.
	 */
	this(addr: sockaddr_in)
	{
		assert(addr.sin_family == AddressFamily.INET);
		sin = addr;
	}

	/// Human readable string representing the IPv4 address in dotted-decimal form.
	override fn toAddrString() string
	{
		return .toString(inet_ntoa(sin.sin_addr));
	}

	/// Human readable string representing the IPv4 port.
	override fn toPortString() string
	{
		return .toString(port);
	}

	/**
	 * Attempts to retrieve the host name as a fully qualified domain name.
	 *
	 * Returns: The FQDN corresponding to this $(D InternetAddress), or
	 * $(D null) if the host name did not resolve.
	 *
	 * Throws: $(D AddressException) on error.
	 */
	override fn toHostNameString() string
	{
		return super.toHostNameString();
	}

	/**
	 * Compares with another InternetAddress of same type for equality
	 * Returns: true if the InternetAddresses share the same address and
	 * port number.
	 */
	fn opEquals(o: Object) bool
	{
		other := cast(InternetAddress)o;
		return other !is null && this.sin.sin_addr.s_addr == other.sin.sin_addr.s_addr &&
			this.sin.sin_port == other.sin.sin_port;
	}

	/**
	 * Parse an IPv4 address string in the dotted-decimal form $(I a.b.c.d)
	 * and return the number.
	 * Returns: If the string is not a legitimate IPv4 address,
	 * $(D ADDR_NONE) is returned.
	 */
	global fn parse(addr: const(char)[]) u32
	{
		return ntohl(inet_addr(toStringz(addr)));
	}

	/**
	 * Convert an IPv4 address number in host byte order to a human readable
	 * string representing the IPv4 address in dotted-decimal form.
	 */
	global fn addrToString(addr: u32) string
	{
		sin_addr: in_addr;
		sin_addr.s_addr = htonl(addr);
		return .toString(inet_ntoa(sin_addr));
	}
}

/**
 * $(D Internet6Address) encapsulates an IPv6 (Internet Protocol version 6)
 * socket address.
 *
 * Consider using $(D getAddress), $(D parseAddress) and $(D Address) methods
 * instead of using this class directly.
 */
class Internet6Address: Address
{
protected:
	sin6: sockaddr_in6;

public:
	this()
	{
	}

	override @property fn name() sockaddr*
	{
		return cast(sockaddr*)&sin6;
	}

	override @property fn nameLen() socklen_t
	{
		return cast(socklen_t) typeid(sin6).size;
	}

		/// Any IPv6 host address.
	global @property fn ADDR_ANY() u8[16]
	{
		addr: u8[16]*;
		version (Posix) {
			addr = &in6addr_any.u.s6_addr;
			return *addr;
		} else version (Windows) {
			addr = &IN6ADDR_ANY.s6_addr;
			return *addr;
		} else {
			static assert(false);
		}
	}

	/// Any IPv6 port number.
	enum u16 PORT_ANY = 0;

	/// Returns the IPv6 port number.
	@property fn port() u16
	{
		return ntohs(sin6.sin6_port);
	}

	/// Returns the IPv6 address.
	@property fn addr() u8[16]
	{
		return sin6.sin6_addr.s6_addr;
	}

	/**
	 * Construct a new $(D Internet6Address).
	 * Params:
	 *   addr    = an IPv6 host address string in the form described in RFC 2373,
	 *             or a host name which will be resolved using $(D getAddressInfo).
	 *   service = (optional) service name.
	 */
	this(addr: const(char)[], service: const(char)[] = null)
	{
		ais: AddressInfoSearcher;
		ais.addHint(service);
		ais.addHint(AddressFamily.INET6);
		results := ais.get(addr);
		assert(results.length && results[0].family == AddressFamily.INET6);
		sin6 = *cast(sockaddr_in6*)results[0].address.name;
	}

	/**
	 * Construct a new $(D Internet6Address).
	 * Params:
	 *   addr = an IPv6 host address string in the form described in RFC 2373,
	 *          or a host name which will be resolved using $(D getAddressInfo).
	 *   port = port number, may be $(D PORT_ANY).
	 */
	this(addr: const(char)[], port: u16)
	{
		if (port == PORT_ANY) {
			this(addr);
		} else {
			this(addr, .toString(port));
		}
	}

	/**
	 * Construct a new $(D Internet6Address).
	 * Params:
	 *   addr = (optional) an IPv6 host address in host byte order, or
	 *          $(D ADDR_ANY).
	 *   port = port number, may be $(D PORT_ANY).
	 */
	this(addr: u8[16], port: u16)
	{
		sin6.sin6_family = AddressFamily.INET6;
		sin6.sin6_addr.s6_addr = addr;
		sin6.sin6_port = htons(port);
	}

	/// ditto
	this(port: u16)
	{
		sin6.sin6_family = AddressFamily.INET6;
		sin6.sin6_addr.s6_addr = ADDR_ANY;
		sin6.sin6_port = htons(port);
	}

	 /**
	  * Construct a new $(D Internet6Address).
	  * Params:
	  *   addr = A sockaddr_in6 as obtained from lower-level API calls such as getifaddrs.
	  */
	this(addr: sockaddr_in6)
	{
		assert(addr.sin6_family == AddressFamily.INET6);
		sin6 = addr;
	}

   /**
	 * Parse an IPv6 host address string as described in RFC 2373, and return the
	 * address.
	 * Throws: $(D SocketException) on error.
	 */
	global fn parse(addr: const(char)[]) u8[16]
	{
		// Although we could use inet_pton here, it's only available on Windows
		// versions starting with Vista, so use getAddressInfo with NUMERICHOST
		// instead.
		ais: AddressInfoSearcher;
		ais.addHint(AddressInfoFlags.NUMERICHOST);
		results := ais.get(addr);
		if (results.length && results[0].family == AddressFamily.INET6) {
			return (cast(sockaddr_in6*)results[0].address.name).sin6_addr.s6_addr;
		}
		throw new AddressException("Not an IPv6 address");
	}
}

version (Posix) {
	class UnixAddress: Address
	{
	protected:
		struct _s
		{
		align (1):
			sun: sockaddr_un;
			unused: char;// = '\0'; // placeholder for a terminating '\0'
		}
		s: _s;

	public:
		this()
		{
			s.sun.sun_family = AddressFamily.UNIX;
			s.sun.sun_path[0] = '?';
		}

		override @property fn name() sockaddr*
		{
			return cast(sockaddr*)&s.sun;
		}

		override @property fn nameLen() socklen_t
		{
			return cast(socklen_t)strlen(cast(const(char)*)s.sun.sun_path.ptr) + 1 + cast(socklen_t)typeid(sa_family_t).size;
		}

		this(path: const(char)[])
		{
			if (path.length > typeid(s.sun.sun_path).size) {
				throw new SocketException("path too long");
			}
			s.sun.sun_family = AddressFamily.UNIX;
			s.sun.sun_path.ptr[0..path.length] = (cast(i8[]) path)[];
			s.sun.sun_path.ptr[path.length] = 0;
		}

		this(addr: sockaddr_un)
		{
			assert(addr.sun_family == AddressFamily.UNIX);
			s.sun = addr;
		}

		@property fn path() string
		{
			return .toString(cast(const(char)*)s.sun.sun_path.ptr);
		}

		override fn toString() string
		{
			return path;
		}
	}
}

/// How a socket is shutdown:
enum SocketShutdown: i32
{
	RECEIVE =  SD_RECEIVE,      //< socket receives are disallowed
	SEND =     SD_SEND,         //< socket sends are disallowed
	BOTH =     SD_BOTH,         //< both RECEIVE and SEND
}


/// Flags may be OR'ed together:
enum SocketFlags: i32
{
	NONE =       0,                 //< no flags specified

	OOB =        MSG_OOB,           //< out-of-band stream data
	PEEK =       MSG_PEEK,          //< peek at incoming data without removing it from the queue, only for receiving
	DONTROUTE =  MSG_DONTROUTE,     //< data should not be subject to routing; this flag may be ignored. Only for sending
}

/// Duration timeout value.
struct TimeVal
{
	ctimeval: timeval;

	@property fn seconds() tv_sec_t
	{
		return ctimeval.tv_sec;
	}

	@property fn seconds(val: tv_sec_t)
	{
		ctimeval.tv_sec = val;
	}

	@property fn microseconds() tv_usec_t
	{
		return ctimeval.tv_usec;
	}

	@property fn microseconds(val: tv_usec_t)
	{
		ctimeval.tv_usec = val;
	}
}

/// The level at which a socket option is defined:
enum SocketOptionLevel: i32
{
	SOCKET =  SOL_SOCKET,               //< Socket level
	IP =      ProtocolType.IP,          //< Internet Protocol version 4 level
	ICMP =    ProtocolType.ICMP,        //< Internet Control Message Protocol level
	IGMP =    ProtocolType.IGMP,        //< Internet Group Management Protocol level
	GGP =     ProtocolType.GGP,         //< Gateway to Gateway Protocol level
	TCP =     ProtocolType.TCP,         //< Transmission Control Protocol level
	PUP =     ProtocolType.PUP,         //< PARC Universal Packet Protocol level
	UDP =     ProtocolType.UDP,         //< User Datagram Protocol level
	IDP =     ProtocolType.IDP,         //< Xerox NS protocol level
	RAW =     ProtocolType.RAW,         //< Raw IP packet level
	IPV6 =    ProtocolType.IPV6,        //< Internet Protocol version 6 level
}

struct Linger
{
	clinger: linger;

	@property fn on() l_onoff_t
	{
		return clinger.l_onoff;
	}

	@property fn on(val: l_onoff_t)
	{
		clinger.l_onoff = val;
	}

	@property fn time() l_linger_t
	{
		return clinger.l_linger;
	}

	@property fn time(val: l_linger_t)
	{
		clinger.l_linger = val;
	}
}

/// Specifies a socket option:
enum SocketOption
{
	DEBUG =                SO_DEBUG,            //< Record debugging information
	BROADCAST =            SO_BROADCAST,        //< Allow transmission of broadcast messages
	REUSEADDR =            SO_REUSEADDR,        //< Allow local reuse of address
	LINGER =               SO_LINGER,           //< Linger on close if unsent data is present
	OOBINLINE =            SO_OOBINLINE,        //< Receive out-of-band data in band
	SNDBUF =               SO_SNDBUF,           //< Send buffer size
	RCVBUF =               SO_RCVBUF,           //< Receive buffer size
	DONTROUTE =            SO_DONTROUTE,        //< Do not route
	SNDTIMEO =             SO_SNDTIMEO,         //< Send timeout
	RCVTIMEO =             SO_RCVTIMEO,         //< Receive timeout
	ERROR =                SO_ERROR,            //< Retrieve and clear error status
	KEEPALIVE =            SO_KEEPALIVE,        //< Enable keep-alive packets
	ACCEPTCONN =           SO_ACCEPTCONN,       //< Listen
	RCVLOWAT =             SO_RCVLOWAT,         //< Minimum number of input bytes to process
	SNDLOWAT =             SO_SNDLOWAT,         //< Minimum number of output bytes to process
	TYPE =                 SO_TYPE,             //< Socket type

	// SocketOptionLevel.TCP:
	TCP_NODELAY =          .TCP_NODELAY,        //< Disable the Nagle algorithm for send coalescing

	// SocketOptionLevel.IPV6:
	IPV6_UNICAST_HOPS =    .IPV6_UNICAST_HOPS,          //< IP unicast hop limit
	IPV6_MULTICAST_IF =    .IPV6_MULTICAST_IF,          //< IP multicast interface
	IPV6_MULTICAST_LOOP =  .IPV6_MULTICAST_LOOP,        //< IP multicast loopback
	IPV6_MULTICAST_HOPS =  .IPV6_MULTICAST_HOPS,        //< IP multicast hops
	IPV6_JOIN_GROUP =      .IPV6_JOIN_GROUP,            //< Add an IP group membership
	IPV6_LEAVE_GROUP =     .IPV6_LEAVE_GROUP,           //< Drop an IP group membership
	IPV6_V6ONLY =          .IPV6_V6ONLY,                //< Treat wildcard bind as AF_INET6-only
}

/**
 * $(D Socket) is a class that creates a network communication endpoint using
 * the Berkeley sockets interface.
 */
class Socket
{
private:
	sock: socket_t;
	_family: AddressFamily;

	version (Windows)
	{
		_blocking := false;  //< Is the socket blocking or non-blocking?
	}

	// The WinSock timeouts seem to be effectively skewed by a constant
	// offset of about half a second (value in milliseconds). This has
	// been confirmed on updated (as of Jun 2011) Windows XP, Windows 7
	// and Windows Server 2008 R2 boxes.
	enum WINSOCK_TIMEOUT_SKEW = 500;

	fn setSock(handle: socket_t)
	{
		assert(handle != socket_t.init);
		sock = handle;
		version (OSX) {
			setOption(SocketOptionLevel.SOCKET, cast(SocketOption)SO_NOSIGPIPE, true);
		}
	}

public:
	this()
	{
	}

	/**
	 * Create a blocking socket. If a single protocol type exists to support
	 * this socket type within the address family, the $(D ProtocolType) may be
	 * omitted.
	 */
	this(af: AddressFamily, type: SocketType, protocol: ProtocolType)
	{
		_family = af;
		handle := cast(socket_t)socket(af, type, protocol);
		if (handle == socket_t.init) {
			throw new SocketOSException("unable to create socket");
		}
		setSock(handle);
	}

	this(af: AddressFamily, type: SocketType)
	{
		this(af, type, cast(ProtocolType)0);
	}

	this(af: AddressFamily, type: SocketType, protocolName: const(char)[])
	{
		proto: protoent* = getprotobyname(toStringz(protocolName));
		if (proto is null) {
			throw new SocketOSException("unable to find protocol");
		}
		this(af, type, cast(ProtocolType)proto.p_proto);
	}

	/**
	 * Create a blocking socket using the parameters from the specified
	 * $(D AddressInfo) structure.
	 */
	this(info: AddressInfo)
	{
		this(info.family, info.type, info.protocol);
	}

	/// Use an existing socket handle.
	this(sock: socket_t, af: AddressFamily)
	{
		assert(sock != socket_t.init);
		this.sock = sock;
		this._family = af;
	}

	~this()
	{
		close();
	}

	/// Get underlying socket handle.
	@property fn handle() socket_t
	{
		return sock;
	}

	/**
	 * Get socket's blocking flag.
	 *
	 * When a socket is blocking, calls to receive(), accept(), and send()
	 * will block and wait for data/action.
	 * A non-blocking socket will immediately return instead of blocking.
	 */
	@property fn blocking() bool
	{
		version (Windows) {
			return _blocking;
		} else {
			return !(fcntl(handle, F_GETFL, 0) & O_NONBLOCK);
		}
	}

	/**
	 * Set socket's blocking flag.
	 *
	 * When a socket is blocking, calls to receive(), accept(), and send()
	 * will block and wait for data/action.
	 * A non-blocking socket will immediately return instead of blocking.
	 */
	@property fn blocking(byes: bool)
	{
		version (Windows) {
			num: u32 = !byes;
			if (_SOCKET_ERROR == ioctlsocket(sock, FIONBIO, &num)) {
				throw new SocketOSException("couldn't set socket blocking");
			}
		} else {
			x: i32 = fcntl(sock, F_GETFL, 0);
			if (-1 == x) {
				throw new SocketOSException("couldn't set socket blocking");
			}
			if (byes) {
				x &= ~O_NONBLOCK;
			} else {
				x |= O_NONBLOCK;
			}
			if (-1 == fcntl(sock, F_SETFL, x)) {
				throw new SocketOSException("couldn't set socket blocking");
			}
		}
	}

	/// Get the socket's address family.
	@property fn addressFamily() AddressFamily
	{
		return _family;
	}

	/// Property that indicates if this is a valid, alive socket.
	@property fn isAlive() bool
	{
		type: i32;
		typesize: socklen_t = cast(socklen_t)typeid(type).size;
		return !getsockopt(sock, SOL_SOCKET, SO_TYPE, cast(void*)&type, &typesize);
	}

	/// Associate a local address with this socket.
	fn bind(addr: Address)
	{
		if (_SOCKET_ERROR == .bind(sock, addr.name, addr.nameLen)) {
			throw new SocketOSException("unable to bind socket");
		}
	}

	/**
	 * Establish a connection. If the socket is blocking, connect waits for
	 * the connection to be made. If the socket is nonblocking, connect
	 * returns immediately and the connection attempt is still in progress.
	 */
	fn connect(to: Address)
	{
		if (_SOCKET_ERROR == .connect(sock, to.name, to.nameLen)) {
			err: i32 = _lasterr();

			if (!blocking) {
				version (Windows) {
					if (WSAEWOULDBLOCK == err) {
						return;
					}
				} else {
					if (EINPROGRESS == err) {
						return;
					}
				}
			}
			throw new SocketOSException("unable to connect socket", err);
		}
	}

	/**
	 * Listen for an incoming connection. $(D bind) must be called before you
	 * can $(D listen). The $(D backlog) is a request of how many pending
	 * incoming connections are queued until $(D accept)ed.
	 */
	fn listen(backlog: i32)
	{
		if (_SOCKET_ERROR == .listen(sock, backlog)) {
			throw new SocketOSException("unable to listen on socket");
		}
	}

	/**
	 * Called by $(D accept) when a new $(D Socket) must be created for a new
	 * connection. To use a derived class, override this method and return an
	 * instance of your class. The returned $(D Socket)'s handle must not be
	 * set; $(D Socket) has a protected constructor $(D this()) to use in this
	 * situation.
	 */
	protected fn accepting() Socket
	{
		return new Socket();
	}

	/**
	 * Accept an incoming connection. If the socket is blocking, $(D accept)
	 * waits for a connection request. Throws $(D SocketAcceptException) if
	 * unable to _accept. See $(D accepting) for use with derived classes.
	 */
	fn accept() Socket
	{
		newsock := cast(socket_t).accept(sock, null, null);
		if (socket_t.init == newsock) {
			throw new SocketAcceptException("couldn't accept socket connection");
		}
		newSocket: Socket;
		try {
			newSocket = accepting();
			assert(newSocket.sock == socket_t.init);
			
			newSocket.setSock(newsock);
			version (Windows) {
				newSocket._blocking = _blocking;
			}
			newSocket._family = _family;
		} catch (o: Throwable) {
			_close(newsock);
			throw o;
		}
		return newSocket;
	}

	/// Disables sends and/or receives.
	fn shutdown(how: SocketShutdown)
	{
		.shutdown(sock, cast(i32)how);
	}

	private global fn _close(sock: socket_t)
	{
		version (Windows) {
			.closesocket(sock);
		} else {
			.close(sock);
		}
	}

	/**
	 * Immediately drop any connections and release socket resources.
	 * Calling $(D shutdown) before $(D close) is recommended for
	 * connection-oriented sockets. The $(D Socket) object is no longer
	 * usable after $(D close).
	 */
	fn close()
	{
		_close(sock);
		sock = socket_t.init;
	}

	/// Returns the local machine's host name.
	global @property fn hostName() string
	{
		result: char[256];
		version (Windows) {
			length := cast(i32)result.length;
		} else {
			length := result.length;
		}
		if (_SOCKET_ERROR == .gethostname(result.ptr, length)) {
			throw new SocketOSException("couldn't obtain hostname");
		}
		return .toString(result.ptr);
	}

	/** Returns a new Address object for the current address family.
	 * Can be overridden to support other addresses.
	 */
	protected fn createAddress() Address
	{
		result: Address;
		switch (_family) {
		case AddressFamily.UNIX:
			version (Posix) {
				result = new UnixAddress();
				break;
			} else {
				throw new SocketException("unix address family on non posix platform");
			}
		case AddressFamily.INET:
			result = new InternetAddress();
			break;
		case AddressFamily.INET6:
			result = new Internet6Address();
			break;
		default:
			result = new UnknownAddress();
			break;
		}
		return result;
	}

	/// Remote endpoint $(D Address).
	@property fn remoteAddress() Address
	{
		addr := createAddress();
		nameLen := addr.nameLen;
		if (_SOCKET_ERROR == .getpeername(sock, addr.name, &nameLen)) {
			throw new SocketOSException("unable to obtain remote socket address");
		}
		if (nameLen > addr.nameLen) {
			throw new SocketException("not enough socket address storage");
		}
		assert(addr.addressFamily == _family);
		return addr;
	}

	/// Local endpoint $(D Address).
	@property fn localAddress() Address
	{
		addr := createAddress();
		nameLen := addr.nameLen;
		if (_SOCKET_ERROR == .getsockname(sock, addr.name, &nameLen)) {
			throw new SocketOSException("Unable to obtain local socket address");
		} else if (nameLen > addr.nameLen) {
			throw new SocketException("Not enough socket address storage");
		}
		assert(addr.addressFamily == _family);
		return addr;
	}

	/**
	 * Send or receive error code. See $(D wouldHaveBlocked),
	 * $(D lastSocketError) and $(D Socket.getErrorText) for obtaining more
	 * information about the error.
	 */
	enum ERROR = _SOCKET_ERROR;

	private global fn capToInt(size: size_t) i32
	{
		// Windows uses i32 instead of size_t for length arguments.
		// Luckily, the send/recv functions make no guarantee that
		// all the data is sent, so we use that to send at most
		// int.max bytes.
		return size > i32.max ? i32.max : cast(i32)size;
	}

	/**
	 * Send data on the connection. If the socket is blocking and there is no
	 * buffer space left, $(D send) waits.
	 * Returns: The number of bytes actually sent, or $(D Socket.ERROR) on
	 * failure.
	 */
	fn send(buf: const(void)[], flags: SocketFlags) ptrdiff_t
	{
		version (Linux) {
			flags = cast(SocketFlags)(flags | cast(SocketFlags)MSG_NOSIGNAL);
		}
		version(Windows) {
			sent := .send(sock, buf.ptr, capToInt(buf.length), cast(i32)flags);
		} else {
			sent := .send(sock, buf.ptr, buf.length, cast(i32)flags);
		}
		return sent;
	}

	/// ditto
	fn send(buf: const(void)[]) ptrdiff_t
	{
		return send(buf, SocketFlags.NONE);
	}

	/**
	 * Send data to a specific destination Address. If the destination address is
	 * not specified, a connection must have been made and that address is used.
	 * If the socket is blocking and there is no buffer space left, $(D sendTo) waits.
	 * Returns: The number of bytes actually sent, or $(D Socket.ERROR) on
	 * failure.
	 */
	fn sendTo(buf: const(void)[], flags: SocketFlags, to: Address) ptrdiff_t
	{
		version (Linux) {
			flags = cast(SocketFlags)(flags | cast(SocketFlags)MSG_NOSIGNAL);
		}
		version(Windows) {
			return .sendto(
					   sock, buf.ptr, capToInt(buf.length),
					   cast(i32)flags, to.name, to.nameLen
					   );
		} else {
			return .sendto(sock, buf.ptr, buf.length, cast(i32)flags, to.name, to.nameLen);
		}
	}

	/// ditto
	fn sendTo(buf: const(void)[], to: Address) ptrdiff_t
	{
		return sendTo(buf, SocketFlags.NONE, to);
	}

	//assumes you connect()ed
	/// ditto
	fn sendTo(buf: const(void)[], flags: SocketFlags) ptrdiff_t
	{
		version (Linux) {
			flags = cast(SocketFlags)(flags | cast(SocketFlags)MSG_NOSIGNAL);
		}
		version(Windows) {
			return .sendto(sock, buf.ptr, capToInt(buf.length), cast(i32)flags, null, 0);
		} else {
			return .sendto(sock, buf.ptr, buf.length, cast(i32)flags, null, 0);
		}
	}

	//assumes you connect()ed
	/// ditto
	fn sendTo(buf: const(void)[]) ptrdiff_t
	{
		return sendTo(buf, SocketFlags.NONE);
	}

	/**
	 * Receive data on the connection. If the socket is blocking, $(D receive)
	 * waits until there is data to be received.
	 * Returns: The number of bytes actually received, $(D 0) if the remote side
	 * has closed the connection, or $(D Socket.ERROR) on failure.
	 */
	//returns number of bytes actually received, 0 on connection closure, or -1 on error
	fn receive(buf: void[], flags: SocketFlags) ptrdiff_t
	{
		version(Windows) {  // Does not use size_t
			return buf.length
				   ? .recv(sock, buf.ptr, capToInt(buf.length), cast(i32)flags)
				   : 0;
		} else {
			return buf.length
				   ? .recv(sock, buf.ptr, buf.length, cast(i32)flags)
				   : cast(ptrdiff_t)0;
		}
	}

	/// ditto
	fn receive(buf: void[]) ptrdiff_t
	{
		return receive(buf, SocketFlags.NONE);
	}

	/**
	 * Receive data and get the remote endpoint $(D Address).
	 * If the socket is blocking, $(D receiveFrom) waits until there is data to
	 * be received.
	 * Returns: The number of bytes actually received, $(D 0) if the remote side
	 * has closed the connection, or $(D Socket.ERROR) on failure.
	 */
	fn receiveFrom(buf: void[], flags: SocketFlags, ref from: Address) ptrdiff_t
	{
		if (!buf.length) {  // return 0 and don't think the connection closed
			return 0;
		}
		if (from is null || from.addressFamily != _family) {
			from = createAddress();
		}
		nameLen: socklen_t = from.nameLen;
		version(Windows) {
			read := .recvfrom(sock, buf.ptr, capToInt(buf.length), cast(i32)flags, from.name, &nameLen);
			assert(from.addressFamily == _family);
			// if (!read) //connection closed
			return read;
		} else {
			read := .recvfrom(sock, buf.ptr, buf.length, cast(i32)flags, from.name, &nameLen);
			assert(from.addressFamily == _family);
			// if (!read) //connection closed
			return read;
		}
	}

	/// ditto
	fn receiveFrom(buf: void[], ref from: Address) ptrdiff_t
	{
		return receiveFrom(buf, SocketFlags.NONE, ref from);
	}

	//assumes you connect()ed
	/// ditto
	fn receiveFrom(buf: void[], flags: SocketFlags) ptrdiff_t
	{
		if (!buf.length) {  // return 0 and don't think the connection closed
			return 0;
		}
		version(Windows) {
			read := .recvfrom(sock, buf.ptr, capToInt(buf.length), cast(i32)flags, null, null);
			// if (!read) //connection closed
			return read;
		} else {
			read := .recvfrom(sock, buf.ptr, buf.length, cast(i32)flags, null, null);
			// if (!read) //connection closed
			return read;
		}
	}

	//assumes you connect()ed
	/// ditto
	fn receiveFrom(buf: void[]) ptrdiff_t
	{
		return receiveFrom(buf, SocketFlags.NONE);
	}

	/// Get a socket option.
	/// Returns: The number of bytes written to $(D result).
	//returns the length, in bytes, of the actual result - very different from getsockopt()
	fn getOption(level: SocketOptionLevel, option: SocketOption, result: void[]) i32
	{
		len := cast(socklen_t)result.length;
		if (_SOCKET_ERROR == .getsockopt(sock, cast(i32)level, cast(i32)option, result.ptr, &len)) {
			throw new SocketOSException("Unable to get socket option");
		}
		return cast(i32)len;
	}

	/// Common case of getting integer and boolean options.
	fn getOption(level: SocketOptionLevel, option: SocketOption, out result: i32) i32
	{
		return getOption(level, option, cast(void[])(&result)[0 .. 1]);
	}

	/// Get the linger option.
	fn getOption(level: SocketOptionLevel, option: SocketOption, out result: Linger) i32
	{
		//return getOption(cast(SocketOptionLevel)SocketOptionLevel.SOCKET, SocketOption.LINGER, (&result)[0 .. 1]);
		return getOption(level, option, cast(void[])(&result.clinger)[0 .. 1]);
	}

	/// Get a timeout (duration) option, in milliseconds.
	fn getTimeoutOption(level: SocketOptionLevel, option: SocketOption, out result: i64)
	{
		if (option != SocketOption.SNDTIMEO && option != SocketOption.RCVTIMEO) {
			throw new SocketException("invalid timeout option");
		}
		// WinSock returns the timeout values as a milliseconds DWORD,
		// while Linux and BSD return a timeval struct.
		version (Windows) {
			msecs: i32;
			getOption(level, option, cast(void[])(&msecs)[0 .. 1]);
			if (option == SocketOption.RCVTIMEO) {
				msecs += WINSOCK_TIMEOUT_SKEW;
			}
			result = msecs;
		} else {
			tv: TimeVal;
			getOption(level, option, cast(void[])(&tv.ctimeval)[0..1]);
			result = tv.seconds * 1000 + tv.microseconds / 1000;
		}
	}

	/// Set a socket option.
	fn setOption(level: SocketOptionLevel, option: SocketOption, value: void[])
	{
		if (_SOCKET_ERROR == .setsockopt(sock, cast(i32)level,
			cast(i32)option, value.ptr, cast(socklen_t) value.length)) {
			throw new SocketException("couldn't set socket option");
		}
	}

	/// Common case for setting integer and boolean options.
	fn setOption(level: SocketOptionLevel, option: SocketOption, value: i32)
	{
		setOption(level, option, cast(void[])(&value)[0 .. 1]);
	}

	/// Set the linger option.
	fn setOption(level: SocketOptionLevel, option: SocketOption, value: Linger)
	{
		setOption(level, option, cast(void[])(&value.clinger)[0 .. 1]);
	}

	global fn splitMillisecondsIntoTimeval(value: i64, tv: timeval*)
	{
		seconds := value / 1000;
		value -= seconds * 1000;
		useconds := value * 1000;
		tv.tv_sec = cast(i32)seconds;
		tv.tv_usec = cast(i32)useconds;
	}

	/**
	 * Sets a timeout (duration) option, i.e. $(D SocketOption.SNDTIMEO) or
	 * $(D RCVTIMEO). Zero indicates no timeout.
	 *
	 * In a typical application, you might also want to consider using
	 * a non-blocking socket instead of setting a timeout on a blocking one.
	 *
	 * Note: While the receive timeout setting is generally quite accurate
	 * on *nix systems even for smaller durations, there are two issues to
	 * be aware of on Windows: First, although undocumented, the effective
	 * timeout duration seems to be the one set on the socket plus half
	 * a second. $(D setOption()) tries to compensate for that, but still,
	 * timeouts under 500ms are not possible on Windows. Second, be aware
	 * that the actual amount of time spent until a blocking call returns
	 * randomly varies on the order of 10ms.
	 *
	 * Params:
	 *   level  = The level at which a socket option is defined.
	 *   option = Either $(D SocketOption.SNDTIMEO) or $(D SocketOption.RCVTIMEO).
	 *   value  = The timeout duration to set in milliseconds. Must not be negative.
	 *
	 * Throws: $(D SocketException) if setting the options fails.
	 *
	 * Example:
	 * ---
	 * import std.datetime;
	 * import std.typecons;
	 * auto pair = socketPair();
	 * scope(exit) foreach (s; pair) s.close();
	 *
	 * // Set a receive timeout, and then wait at one end of
	 * // the socket pair, knowing that no data will arrive.
	 * pair[0].setOption(SocketOptionLevel.SOCKET,
	 *     SocketOption.RCVTIMEO, dur!"seconds"(1));
	 *
	 * auto sw = StopWatch(Yes.autoStart);
	 * ubyte[1] buffer;
	 * pair[0].receive(buffer);
	 * writefln("Waited %s ms until the socket timed out.",
	 *     sw.peek.msecs);
	 * ---
	 */
	fn setTimeoutOption(level: SocketOptionLevel, option: SocketOption, value: i64)
	{
		if (option != SocketOption.SNDTIMEO && option != SocketOption.RCVTIMEO) {
			throw new SocketException("not a valid timeout option");
		}
		if (value < 0) {
			throw new SocketException("timeout duration may not be negative");
		}

		version (Windows) {
			value -= WINSOCK_TIMEOUT_SKEW;
			if (value <= 0) {
				value = 1;
			}
			if (value >= i32.max) {
				value = i32.max;
			}
			setOption(level, option, cast(i32)value);
		} else {
			tv: timeval;
			splitMillisecondsIntoTimeval(value, &tv);
			setOption(level, option, cast(void[])(&tv)[0 .. 1]);
		}
	}

	/**
	 * Enables TCP keep-alive with the specified parameters.
	 *
	 * Params:
	 *   time     = Number of seconds with no activity until the first
	 *              keep-alive packet is sent.
	 *   interval = Number of seconds between when successive keep-alive
	 *              packets are sent if no acknowledgement is received.
	 *
	 * Throws: $(D SocketOSException) if setting the options fails, or
	 * $(D SocketFeatureException) if setting keep-alive parameters is
	 * unsupported on the current platform.
	 */
	fn setKeepAlive(time: i32, interval: i32)
	{
		version(Windows) {
			options: tcp_keepalive;
			options.onoff = 1;
			options.keepalivetime = cast(u32)time * 1000;
			options.keepaliveinterval = cast(u32)interval * 1000;
			cbBytesReturned: u32;
			if (WSAIoctl(sock, cast(u32)SIO_KEEPALIVE_VALS,
				cast(void*)&options, cast(u32)typeid(options).size,
				null, 0,
				&cbBytesReturned, null, cast(LPWSAOVERLAPPED_COMPLETION_ROUTINE)null) != 0) {
				throw new SocketOSException("Error setting keep-alive");
			}
		} else {
			throw new SocketException("keep-alive not supported on this platform");
		}
	}
}

/// $(D TcpSocket) is a shortcut class for a TCP Socket.
class TcpSocket: Socket
{
	/// Constructs a blocking TCP Socket.
	this(family: AddressFamily)
	{
		super(family, SocketType.STREAM, ProtocolType.TCP);
	}

	/// Constructs a blocking IPv4 TCP Socket.
	this()
	{
		this(AddressFamily.INET);
	}

	/// Constructs a blocking TCP Socket and connects to an $(D Address).
	this(connectTo: Address)
	{
		this(connectTo.addressFamily);
		connect(connectTo);
	}
}


/// $(D UdpSocket) is a shortcut class for a UDP Socket.
class UdpSocket: Socket
{
	/// Constructs a blocking UDP Socket.
	this(family: AddressFamily)
	{
		super(family, SocketType.DGRAM, ProtocolType.UDP);
	}

	/// Constructs a blocking IPv4 UDP Socket.
	this()
	{
		this(AddressFamily.INET);
	}    
}

/**
 * Creates a pair of connected sockets.
 *
 * The two sockets are indistinguishable.
 *
 * Throws: $(D SocketException) if creation of the sockets fails.
 */
fn socketPair() Socket[2]
{
	version(Posix) {
		socks: i32[2];
		if (socketpair(AF_UNIX, SOCK_STREAM, 0, ref socks) == -1) {
			throw new SocketOSException("Unable to create socket pair");
		}

		fn toSocket(id: size_t) Socket
		{
			s := new Socket();
			s.setSock(cast(socket_t)socks[id]);
			s._family = AddressFamily.UNIX;
			return s;
		}

		return [toSocket(0), toSocket(1)];
	} else version(Windows) {
		// We do not have socketpair() on Windows, just manually create a
		// pair of sockets connected over some localhost port.
		result: Socket[2];

		listener := new TcpSocket();
		listener.setOption(SocketOptionLevel.SOCKET, SocketOption.REUSEADDR, true);
		listener.bind(new InternetAddress(INADDR_LOOPBACK, InternetAddress.PORT_ANY));
		addr := listener.localAddress;
		listener.listen(1);

		result[0] = new TcpSocket(addr);
		result[1] = listener.accept();

		listener.close();
		return result;
	} else {
		static assert(false);
	}
}
