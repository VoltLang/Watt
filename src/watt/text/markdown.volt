/*!
	Markdown parser implementation
	Copyright: © 2012-2015 RejectedSoftware e.K.
	License:
		Boost Software License - Version 1.0 - August 17th, 2003
		Permission is hereby granted, free of charge, to any person or organization
		obtaining a copy of the software and accompanying documentation covered by
		this license (the "Software") to use, reproduce, display, distribute,
		execute, and transmit the Software, and to prepare derivative works of the
		Software, and to permit third-parties to whom the Software is furnished to
		do so, all subject to the following:
		The copyright notices in the Software and this entire statement, including
		the above license grant, this restriction and the following disclaimer,
		must be included in all copies of the Software, in whole or in part, and
		all derivative works of the Software, unless such copies or derivative
		works are solely in the form of machine-executable object code generated by
		a source language processor.
		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
		SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
		FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
		ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
		DEALINGS IN THE SOFTWARE.
	Authors: Sönke Ludwig
*/
module watt.text.markdown;

import watt.io;  // TODO: Remove
import watt.algorithm: min;
import watt.conv: toString, toLower;
import watt.text.ascii: isAlpha, isWhite, isDigit;
import watt.text.string: splitLines, stripLeft, stripRight, startsWith, strip, join, endsWith, indexOf, count, lastIndexOf;
import watt.text.format: format;
import watt.text.utf: encode, decode;
import watt.text.sink;
import watt.text.html;

/*
	TODO:
		detect inline HTML tags
*/

//! Returns false if str contains a character that's not in chars.
fn allOf(str: string, chars: string) bool
{
	foreach (c: dchar; str) {
		if (indexOf(chars, c) == -1) {
			return false;
		}
	}
	return true;
}

//! Returns true if str contains any characters in chars.
fn anyOf(str: string, chars: string) bool
{
	foreach (c: dchar; str) {
		if (indexOf(chars, c) != -1) {
			return true;
		}
	}
	return false;
}

//! Returns how many of chr str starts with.
fn countLeading(str: string, chr: dchar) size_t
{
	foreach (i, c: dchar; str) {
		if (c != chr) {
			return i;
		}
	}
	return str.length;
}

//! Finds the index of the closing bracket if str starts with [, (, <, or {.
//! -1 on failure.
private fn matchBracket(str: string, nested: bool = true) ptrdiff_t
{
	if (str.length < 2) {
		return -1;
	}

	open: dchar = str[0];
	close: dchar;
	switch (str[0]) {
	case '[': close = ']'; break;
	case '(': close = ')'; break;
	case '<': close = '<'; break;
	case '{': close = '}'; break;
	default: return -1;
	}

	level: size_t = 1;
	escape: bool;
	foreach (i, c: dchar; str[1 .. $]) {
		if (c == '\\') {
			escape = true;
			continue;
		}
		if (escape && c == close) {
			escape = false;
			continue;
		} else {
			escape = false;
		}
		if (nested && c == open) {
			++level;
		} else if (c == close) {
			--level;
		}
		if (level == 0) {
			return cast(ptrdiff_t)(i + 1);
		}
	}

	return -1;
}


fn backslashEscape(str: string) string
{
	dst: StringSink;
	next: bool = false;
	foreach (c: dchar; str) {
		if (!next && c != '\\') {
			dst.sink(encode(c));
			continue;
		}
		if (!next) {
			next = true;
			continue;
		}
		switch (c) {
		case '!', '\"', '#', '$', '%', '&', '\'', '(', ')', '*',
		     '+', ',', '-', '.', '/', ':', ';', '<', '=', '>',
		     '?', '@', '[', '\\', ']', '^', '_', '`', '{', '|', '}',
			 '~':
			dst.sink(encode(c));
			break;
		default:
			dst.sink("\\");
			dst.sink(encode(c));
			break;
		}
		next = false;
	}
	return dst.toString();
}


/*! Returns a Markdown filtered HTML string.
*/
fn filterMarkdown(str: string, flags: MarkdownFlags) string
{
	settings := new MarkdownSettings();
	settings.flags = flags;
	return filterMarkdown(str, settings);
}
//! ditto
fn filterMarkdown(str: string, settings: scope MarkdownSettings = null) string
{
	dst: StringSink;
	filterMarkdown(dst.sink, str, settings);
	return dst.toString();
}



/*! Markdown filters the given string and writes the corresponding HTML to an output range.
*/
fn filterMarkdown(dgt: Sink, src: string, flags: MarkdownFlags)
{
	settings := new MarkdownSettings();
	settings.flags = flags;
	filterMarkdown(dgt, src, settings);
}
//! ditto
fn filterMarkdown(dgt: Sink, src: string, settings: scope MarkdownSettings = null)
{
	defsettings := new MarkdownSettings();
	if (settings is null) settings = defsettings;

	all_lines := splitLines(src);
	while (all_lines.length > 0 && isLineBlank(all_lines[$-1])) {
		all_lines = all_lines[0 .. $-1];
	}
	links := new LinkRefs();
	links.scanForReferences(ref all_lines);
	lines := parseLines(ref all_lines, settings);
	root_block: Block;
	parseBlocks(ref root_block, ref lines, null, settings);
	writeBlock(dgt, ref root_block, links, settings);
}

final class MarkdownSettings {
	//! Controls the capabilities of the parser.
	flags: MarkdownFlags = MarkdownFlags.voltDefault;

	//! Heading tags will start at this level.
	headingBaseLevel: size_t = 1;

	//! Called for every link/image URL to perform arbitrary transformations.
	urlFilter: dg (url_or_path: string, is_image: bool) string;
}

enum MarkdownFlags {
	none = 0,
	keepLineBreaks = 1<<0,
	backtickCodeBlocks = 1<<1,
	noInlineHtml = 1<<2,
	//noLinks = 1<<3,
	//allowUnsafeHtml = 1<<4,
	strikeThrough = 1<<5,
	vanillaMarkdown = none,
	forumDefault = keepLineBreaks|backtickCodeBlocks|noInlineHtml,
	voltDefault = backtickCodeBlocks|strikeThrough
}

private {
	global s_blockTags: immutable(string[]) = [
"address", "article", "aside",
"base", "basefont", "blockquote", "body",
"caption", "center", "col", "colgroup",
"dd", "details", "dialog", "dir", "div", "dl", "dt",
"fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset",
"h1", "head", "header", "hr", "html",
"iframe",
"legend", "li", "link",
"main", "menu", "menuitem", "meta",
"nav", "noframes",
"ol", "optgroup", "option",
"p", "param",
"section", "source", "summary",
"table", "tbody", "td", "tfoot", "th", "thead", "title", "track",
"ul"
];

	global s_literalTags: immutable(string[]) = [
"script", "style", "pre"
];
}

private enum IndentType {
	White,
	Quote
}

private enum LineType {
	Undefined,
	Blank,
	Plain,
	Hline,
	AtxHeader,
	SetextHeader,
	UList,
	OList,
	HtmlBlock,
	CodeBlockDelimiter
}

private struct Line {
	type: LineType;
	indent: IndentType[];
	text: string;
	unindented: string;
	hblock: HtmlBlockInfo;
	leadingSpaces: size_t;
	listNum: string;

	fn unindent(n: size_t) string
	{
		assert(n <= indent.length);
		ln: string = text;
		i: size_t;
		while (i < n) {
			final switch (indent[i]) {
			case IndentType.White:
				if (ln.startsWith(" \t")) { ln = ln[2 .. $]; i -= 4; continue; }
				else if (ln.startsWith("  \t")) { ln = ln[3 .. $]; i -= 4; continue; }
				else if (ln.startsWith("   \t")) { ln = ln[4 .. $]; i -= 4; continue; }
				else if (ln.startsWith("\t")) { ln = ln[1 .. $]; i -= 4; continue; }
				else ln = ln[1 .. $];
				break;
			case IndentType.Quote:
				ln = ln.stripLeft()[1 .. $].stripLeft();
				break;
			}
			i++;
		}
		return ln;
	}
}

private fn countOpeningWhitespace(text: string) size_t
{
	i: size_t;
	while (isWhite(text[i])) {
		i++;
	}
	return i;
}

private fn codeUnindent(text: string, listSpaces: size_t) string
{
	if (listSpaces > 0 && text.length >= listSpaces && text[0 .. listSpaces].allOf(" \t")) {
		return codeUnindent(text[listSpaces .. $], 0);
	}
	s: string = text;
	if (s.startsWith("\t")) {
		return s[1 .. $];
	}
	if (s.startsWith(" \t")) {
		return s[2 .. $];
	}
	if (s.startsWith("  \t")) {
		return s[3 .. $];
	}
	if (s.startsWith("   \t")) {
		return s[4 .. $];
	}
	if (s.startsWith("    ")) {
		return s[4 .. $];
	}
	// Doesn't denote a code block, but remove it in one.
	if (s.startsWith("   ")) {
		return s[3 .. $];
	}
	if (s.startsWith("  ")) {
		return s[2 .. $];
	}
	if (s.startsWith(" ")) {
		return s[1 .. $];
	}
	return s;
}

private fn isCode(text: string, leadingSpaces: size_t) bool
{
	s: string = text;
	if (text.length <= leadingSpaces) {
		return false;
	}
	if (leadingSpaces > 0 && !s[0 .. leadingSpaces].allOf(" \t")) {
		return false;
	}
	s = s[leadingSpaces .. $];
	if (s.length > 2 && s.startsWith("> ")) {
		s = s[2 .. $];
	}
	if (s.startsWith("\t")) {
		return true;
	}
	if (s.startsWith(" \t")) {
		return true;
	}
	if (s.startsWith("  \t")) {
		return true;
	}
	if (s.startsWith("   \t")) {
		return true;
	}
	if (s.startsWith("    ")) {
		return true;
	}
	return false;
}

private fn parseLines(ref lines: string[], settings: scope MarkdownSettings) Line[]
{
	ret: Line[];
	for (i: size_t = 0; i < lines.length; ++i) {
		ln := lines[i];

		lninfo: Line;
		lninfo.leadingSpaces = countLeading(ln, ' ');
		lninfo.text = ln;
		lninfo.type = LineType.Plain;

		while (ln.length > 0) {
			fn codeIndent()
			{
				foreach (j; 0 .. 4) {
					lninfo.indent ~= IndentType.White;
				}
			}

			if (ln.startsWith("   \t")) {
				codeIndent();
				ln = ln[4 .. $];
			} else if (ln.startsWith(" \t")) {
				codeIndent();
				ln = ln[2 .. $];
			} else if (ln.startsWith("  \t")) {
				codeIndent();
				ln = ln[3 .. $];
			} else if (ln.startsWith("\t")) {
				codeIndent();
				ln = ln[1 .. $];
			} else if (ln.startsWith(" ")) {
				lninfo.indent ~= IndentType.White;
				ln = ln[1 .. $];
			} else {
				ln = ln.stripLeft();
				if (ln.startsWith(">")) {
					lninfo.indent ~= IndentType.Quote;
					ln = ln[1 .. $];
					ln = ln.stripLeft();
				} else {
					break;
				}
			}
		}
		lninfo.unindented = ln;

		if ((settings.flags & MarkdownFlags.backtickCodeBlocks) && isCodeBlockDelimiter(ln, lninfo.leadingSpaces)) lninfo.type = LineType.CodeBlockDelimiter;
		else if (isAtxHeaderLine(ln, lninfo.leadingSpaces)) lninfo.type = LineType.AtxHeader;
		else if (ret.length > 0 && isSetextHeaderLine(ln, ret[$-1], lninfo.leadingSpaces)) lninfo.type = LineType.SetextHeader;
		else if (isHlineLine(ln, lninfo.leadingSpaces)) lninfo.type = LineType.Hline;
		else if (isOListLine(ln, ref lninfo.listNum)) lninfo.type = LineType.OList;
		else if (isUListLine(ln)) lninfo.type = LineType.UList;
		else if (isLineBlank(ln)) lninfo.type = LineType.Blank;
		else {
			hblock := parseHtmlBlockLine(ln, lninfo.leadingSpaces);
			if (!(settings.flags & MarkdownFlags.noInlineHtml) && hblock.isHtmlBlock) {
				lninfo.type = LineType.HtmlBlock;
				lninfo.hblock = parseHtmlBlockLine(ln, lninfo.leadingSpaces);
			}
		}

		ret ~= lninfo;
	}
	return ret;
}

private enum BlockType {
	Plain,
	Text,
	Paragraph,
	Header,
	OList,
	UList,
	ListItem,
	Code,
	Quote
}

private enum HtmlEnd {
	Literal,  // </script> </pre> </style>
	CloseTag,
	Condition,  // ?>
	Greater,  // >
	Cdata,  //]]>
	BlankLine,
}

private struct Block {
	type: BlockType;
	text: string[];
	blocks: Block[];
	headerLevel: size_t;
	classTag: string;
	listNum: string;
}

private fn parseBlocks(ref root: Block, ref lines: Line[], base_indent: IndentType[], settings: scope MarkdownSettings, list: bool = false)
{
	fn hasQuote(itypes: IndentType[]) bool
	{
		foreach (itype; itypes) {
			if (itype == IndentType.Quote) {
				return true;
			}
		}
		return false;
	}

	if (base_indent.length == 0) root.type = BlockType.Text;
	else if (base_indent[$-1] == IndentType.Quote) root.type = BlockType.Quote;

	skipEmptyBlockQuote: bool;
	blankSkips: size_t;
	while (lines.length > 0) {
		ln := lines[0];

		if (ln.type == LineType.Blank) {
			quoteNext: bool = lines.length > 1 && lines[1].indent.hasQuote();
			if (!quoteNext && ln.indent.hasQuote() && !skipEmptyBlockQuote) {
				// Empty quote.
				b: Block;
				b.type = BlockType.Plain;
				b.text ~= ["<blockquote></blockquote>"];
				root.blocks ~= b;
				skipEmptyBlockQuote = true;
			} else {
				skipEmptyBlockQuote = false;
			}
			if (root.type == BlockType.Quote && !ln.indent.hasQuote()) {
				return;
			}
			blankSkips++;
			if (list && blankSkips >= 2) {
				return;
			}
			lines = lines[1 .. $];
			continue;
		}
		skipEmptyBlockQuote = false;

		l: size_t = base_indent.length >= 4 ? base_indent.length: cast(size_t)0;
		if (list) {
			l += 4;
		}
		if (ln.text.isCode(l)) {
			cblock: Block;
			qblock: Block;
			isQuote: bool;
			if (ln.text.startsWith("> ") || ln.unindented.startsWith("> ")) {
				isQuote = true;
				qblock.type = BlockType.Quote;
			}
			cblock.type = BlockType.Code;
			blanklines: Line[];
			reContinue: bool;
			while (lines.length > 0 && (lines[0].text.isCode(l) || lines[0].type == LineType.Blank )) {
				if (lines[0].indent.hasQuote() && lines[0].text.length >= l + 2) {
					lines[0].text = lines[0].text[l + 2 .. $];
				}
				if (lines[0].type == LineType.Blank) {
					blanklines ~= lines[0];
					lines = lines[1 .. $];
					continue;
				}
				foreach (bline; blanklines) {
					cblock.text ~= bline.text.codeUnindent(l);
				}
				blanklines = [];
				cblock.text ~= lines[0].text.codeUnindent(l);
				lines = lines[1 .. $];
				if (lines.length > 0 && (!lines[0].text.isCode(l) && lines[0].type != LineType.Blank)) {
					break;
				}
				if (lines.length > 0 && isQuote && !lines[0].text.startsWith("> ")) {
					reContinue = true;
					break;
				}
			}
			if (!isQuote) {
				root.blocks ~= cblock;
			} else {
				qblock.blocks ~= cblock;
				root.blocks ~= qblock;
			}
			if (reContinue) {
				continue;
			}
			if (lines.length == 0) {
				return;
			}
			ln = lines[0];
		}

		// Give how much indent a line has. This is different to ln.indent, as it includes white space after quote indent.
		fn lineIndent(s: string) size_t
		{
			i: size_t;
			foreach (c: dchar; s) {
				breakNow: bool;
				switch (c) {
				case ' ': i++; break;
				case '>': i++; break;
				default: breakNow = true; break;
				}
				if (breakNow) {
					break;
				}
			}
			return i;
		}

		if (list && lineIndent(ln.text) >= base_indent.length && ln.type != LineType.UList && ln.type != LineType.OList && hasQuote(base_indent)) {
		} else if (ln.indent != base_indent) {
			if (ln.indent.length < base_indent.length || ln.indent[0 .. base_indent.length] != base_indent )
				return;

			cindent := base_indent ~ [IndentType.White, IndentType.White, IndentType.White, IndentType.White];
			if (ln.indent != cindent || list) {
				subblock: Block;
				parseBlocks(ref subblock, ref lines, ln.indent[0 .. base_indent.length+1], settings, list);
				root.blocks ~= subblock;
				continue;
			} else if (!isCode(ln.text, base_indent.length)) {
				continue;
			}
		}
		b, subblock: Block;
		subblockappend: bool;
		final switch (ln.type) {
		case LineType.Undefined: assert(false);
		case LineType.Blank: assert(false);
		case LineType.Plain:
			if (ln.indent.length > 0 && ln.indent[0] == IndentType.Quote) {
				skipEmptyBlockQuote = true;
			}
			if (lines.length >= 2 && lines[1].type == LineType.SetextHeader &&
				(ln.indent.length == 0 || ln.indent[0] != IndentType.Quote)) {
				if (ln.unindented.startsWith("\\>")) {
					ln.unindented = ln.unindented[1 .. $];
				}
				setln := lines[1].unindented;
				b.type = BlockType.Header;
				b.text = [htmlEscapeIgnoreTags(ln.unindented.stripRight())];
				b.headerLevel = setln.strip()[0] == '=' ? 1: 2;
				lines = lines[2 .. $];
			} else {
				b.type = BlockType.Paragraph;
				b.text = skipText(ref lines, base_indent);
			}
			break;
		case LineType.Hline:
			b.type = BlockType.Plain;
			b.text = ["<hr />"];
			lines = lines[1 .. $];
			break;
		case LineType.AtxHeader:
			b.type = BlockType.Header;
			hl: string = ln.unindented;
			b.headerLevel = 0;
			while (hl.length > 0 && hl[0] == '#') {
				b.headerLevel++;
				hl = hl[1 .. $];
			}

			hl = hl.stripRight();
			endi: size_t = hl.length - 1;
			while (endi > 0 && (hl[endi] == '#' || isWhite(hl[endi]))) {
				endi--;
			}
			endi++;
			if (hl.length > 0 && isWhite(hl[0]) && endi == 1) {
				hl = "";
			} else if ( isWhite(hl[endi])) {
				hl = hl[0 .. endi];
			}

			b.text = [hl];
			lines = lines[1 .. $];
			break;
		case LineType.SetextHeader:
			if (allOf(lines[0].text, "- \t")) {
				goto case LineType.Hline;
			} else if (root.blocks.length > 0 && root.blocks[$-1].type == BlockType.Paragraph) {
				root.blocks[$-1].text ~= ln.text;
				lines = lines[1 .. $];
			}
			break;
		case LineType.UList:
		case LineType.OList:
			b.type = ln.type == LineType.UList ? BlockType.UList: BlockType.OList;
			if (b.type == BlockType.OList) {
				b.listNum = ln.listNum;
			}
			itemindent := base_indent;
			trailing: bool;
			s := ln.unindent(base_indent.length);
			foreach (c: dchar; s) {
				if (isWhite(c)) {
					if (trailing) {
						itemindent ~= IndentType.White;
					}
				} else {
					if (!trailing) {
						trailing = true;
					} else {
						break;
					}
				}
			}
			if (b.type == BlockType.UList || b.type == BlockType.OList) {
				itemindent ~= IndentType.White;
			}
			fn quotes(indents: IndentType[]) size_t
			{
				qcount: size_t;
				foreach (indent; indents) {
					if (indent == IndentType.Quote) {
						qcount++;
					}
				}
				return qcount;
			}
			while (lines.length > 0 && lines[0].type == ln.type && lines[0].indent == base_indent) {
				itm: Block;
				itm.text = skipText(ref lines, itemindent);
				leadingSpace: size_t;
				itm.text[0] = removeListPrefix(itm.text[0], ln.type, ref leadingSpace);
				if ( isHlineInList(itm.text[0], leadingSpace)) {
					itm.text[0] = "<hr />";
				}
				if (lines.length > 1 && quotes(ln.indent) > 0
				    && quotes(ln.indent) == quotes(lines[1].indent) &&
				    lines[1].indent.length >= itemindent.length) {
					subblock.type = BlockType.Paragraph;
					subblock.text = [lines[1].unindent(lines[1].indent.length)];
					lines = lines[2 .. $];
					subblockappend = true;
				}

				if (!subblockappend) {
					oldLength: size_t = itm.blocks.length;
					parseBlocks(ref itm, ref lines, itemindent, settings, true);
					newLength: size_t = itm.blocks.length;
					if (newLength > oldLength) {
						para: Block;
						para.type = BlockType.Paragraph;
						para.text = itm.text;
						itm.blocks = para ~ itm.blocks;
						itm.text = null;
					}
				}
				itm.type = BlockType.ListItem;
				b.blocks ~= itm;
			}
			break;
		case LineType.HtmlBlock:
			nestlevel: i32 = 0;
			starttag := ln.hblock;
			end: HtmlEnd;
			if (!starttag.isHtmlBlock) {
				break;
			} else if (!starttag.open) {
				end = HtmlEnd.BlankLine;
			}

			if (s_literalTags.indexOf(starttag.tagName.toLower()) > -1) {
				end = HtmlEnd.Literal;
			} else if (s_blockTags.indexOf(starttag.tagName.toLower()) > -1 || starttag.uniqueBlankTag) {
				end = HtmlEnd.BlankLine;
			}
			b.type = BlockType.Plain;
			if (starttag.literalInLine.length > 0) {
				b.text ~= starttag.literalInLine;
				lines = lines[1 .. $];
				break;
			}
			if (starttag.isCommentOpenBlock) {
				end = HtmlEnd.CloseTag;
				if (starttag.isCommentCloseBlock && starttag.tagName == starttag.closeTag) {
					b.text ~= format("%s%s", starttag.indent, starttag.fullText);
					lines = lines[1 .. $];
					break;
				}
			}
			while (lines.length > 0) {
				if (lines[0].indent.length < base_indent.length) break;
				if (lines[0].indent[0 .. base_indent.length] != base_indent) break;
				str := lines[0].unindent(base_indent.length);
				taginfo := parseHtmlBlockLine(str);
				b.text ~= format("%s%s", taginfo.indent, lines[0].unindent(base_indent.length));
				lines = lines[1 .. $];
				if (taginfo.isHtmlBlock && taginfo.tagName == starttag.tagName )
					nestlevel += taginfo.open ? 1: -1;
				if (taginfo.isHtmlBlock && end == HtmlEnd.Literal &&
					taginfo.tagName.toLower() == starttag.tagName.toLower() &&
					!taginfo.open) {
					break;
				}
				if (starttag.tagName == "<!" && lines[0].text.indexOf('>') > -1) {
					break;
				}
				if (starttag.isCommentOpenBlock && taginfo.isCommentCloseBlock && starttag.tagName == taginfo.closeTag) {
					break;
				}
				if (end != HtmlEnd.BlankLine && nestlevel <= 0) break;
				if (end == HtmlEnd.BlankLine && lines[0].type == LineType.Blank) break;
			}
			break;
		case LineType.CodeBlockDelimiter:
			tilde: size_t = ln.text.count('~');
			backt: size_t = ln.text.count('`');
			assert((tilde == 0 && backt > 0) || (tilde > 0 && backt == 0));

			// Get language from line if present.
			a: size_t;
			if (tilde > 0) {
				a = cast(size_t)ln.text.indexOf('~');
			} else {
				a = cast(size_t)ln.text.indexOf('`');
			}

			while (a < ln.text.length && (ln.text[a] == '`' || ln.text[a] == '~' || isWhite(ln.text[a]))) {
				a++;
			}

			bi: size_t = a;
			while (bi < ln.text.length && !isWhite(ln.text[bi])) {
				bi++;
			}

			lang: string = ln.text[a .. bi];
			if (lang.length > 0 && lang.count('~') == 0 && lang.count('`') == 0) {
					b.classTag = format("language-%s", lang);
			}

			lines = lines[1 .. $];
			b.type = BlockType.Code;
			while (lines.length != 0) {
				if (hasQuote(base_indent) && !hasQuote(lines[0].indent)) {
					break;
				}
				if (lines[0].type == LineType.CodeBlockDelimiter) {
					if ((tilde > 0 && lines[0].text.count('~') >= tilde && allOf(lines[0].text, "~ \t")) ||
						 backt > 0 && lines[0].text.count('`') >= backt && allOf(lines[0].text, "` \t")) {
						lines = lines[1 .. $];
						break;
					}
				}
				b.text ~= lines[0].unindent(lines[0].indent.length < base_indent.length ? lines[0].indent.length: base_indent.length);
				lines = lines[1 .. $];
			}
			break;
		}
		root.blocks ~= b;
		if (subblockappend) {
			root.blocks ~= subblock;
		}
	}
}

private fn skipText(ref lines: Line[], indent: IndentType[]) string[]
{
	static fn matchesIndent(indent: IndentType[], base_indent: IndentType[]) bool
	{
		if (indent.length > base_indent.length) return false;
		if (indent != base_indent[0 .. indent.length]) return false;
		qidx: ptrdiff_t = -1;
		foreach_reverse (i, tp; base_indent) if (tp == IndentType.Quote) { qidx = cast(ptrdiff_t)i; break; }
		if (qidx >= 0) {
			qidx = cast(ptrdiff_t)(base_indent.length-1) - qidx;
			if (cast(ptrdiff_t)indent.length <= qidx) return false;
		}
		return true;
	}

	ret: string[];

	wasQuote: bool = lines[0].indent.length > 0 && lines[0].indent[0] == IndentType.Quote;
	while (true) {
		ret ~= htmlEscapeIgnoreTags(lines[0].unindent(min(indent.length, lines[0].indent.length)));
		lines = lines[1 .. $];

		if (lines.length > 0) {
			tag := parseHtmlBlockLine(lines[0].text);
			if (tag.uniqueBlankTag)
				continue;
		}

		if (lines.length == 0 || (lines[0].type != LineType.Plain && !(lines[0].type == LineType.UList && lines[0].text.countLeading(' ') >= 4)) || (lines[0].indent.length > 0 && lines[0].indent[0] == IndentType.Quote && !wasQuote))
			return ret;
	}
	assert(false);
}

//! private
private fn writeBlock(dgt: Sink, ref block: const Block, links: LinkRefs, settings: scope MarkdownSettings, fromOrdered: bool = false)
{
	final switch (block.type) {
	case BlockType.Plain:
		foreach( ln; block.text) {
			dgt(ln);
			dgt("\n");
		}
		foreach(b; block.blocks)
			writeBlock(dgt, ref b, links, settings, fromOrdered);
		break;
	case BlockType.Text:
		writeMarkdownEscaped(dgt, ref block, links, settings);
		foreach(b; block.blocks)
			writeBlock(dgt, ref b, links, settings, fromOrdered);
		break;
	case BlockType.Paragraph:
		assert(block.blocks.length == 0);
		dgt("<p>");
		writeMarkdownEscaped(dgt, ref block, links, settings);
		dgt("</p>\n");
		break;
	case BlockType.Header:
		assert(block.blocks.length == 0);
		hlvl := block.headerLevel + (settings ? settings.headingBaseLevel-1: cast(size_t)0);
		dgt(format("<h%s>", hlvl));
		assert(block.text.length == 1);
		writeMarkdownEscaped(dgt, ref block.text[0], links, settings);
		dgt(format("</h%s>\n", hlvl));
		break;
	case BlockType.OList:
		if (block.listNum != "1" && !fromOrdered) {
			dgt(format("<ol start=\"%s\">", block.listNum));
		} else {
			dgt("<ol>\n");
		}
		foreach(b; block.blocks)
			writeBlock(dgt, ref b, links, settings, true);
		dgt("</ol>\n");
		break;
	case BlockType.UList:
		dgt("<ul>\n");
		foreach(b; block.blocks)
			writeBlock(dgt, ref b, links, settings, fromOrdered);
		dgt("</ul>\n");
		break;
	case BlockType.ListItem:
		dgt("<li>");
		writeMarkdownEscaped(dgt, ref block, links, settings);
		foreach(b; block.blocks)
			writeBlock(dgt, ref b, links, settings, fromOrdered);
		dgt("</li>\n");
		break;
	case BlockType.Code:
		assert(block.blocks.length == 0);
		if (block.classTag.length > 0) {
			dgt(format("<pre><code class=\"%s\">", block.classTag));
		} else {
			dgt("<pre><code>");
		}
		foreach(ln; block.text) {
			htmlEscape(dgt, ln);
			dgt("\n");
		}
		dgt("</code></pre>");
		break;
	case BlockType.Quote:
		dgt("<blockquote>");
		writeMarkdownEscaped(dgt, ref block, links, settings);
		foreach(b; block.blocks) {
			writeBlock(dgt, ref b, links, settings, fromOrdered);
		}
		dgt("</blockquote>\n");
		break;
	}
}

private fn writeMarkdownEscaped(dgt: Sink, ref block: const Block, in links: LinkRefs, settings: scope MarkdownSettings)
{
	lines := cast(string[])block.text;
	text := settings.flags & MarkdownFlags.keepLineBreaks ? lines.join("<br>"): lines.join("\n");
	writeMarkdownEscaped(dgt, text, links, settings);
	if (lines.length) dgt("\n");
}

//! private
private fn writeMarkdownEscaped(dgt: Sink, ln: string, linkrefs: LinkRefs, settings: scope MarkdownSettings)
{
	fn filterLink(lnk: string, is_image: bool) string {
		return settings.urlFilter !is null ? settings.urlFilter(lnk, is_image): lnk;
	}

	ln = ln.strip();
	br: bool = ln.endsWith("  ") != 0;
	spaces: size_t;
	fn flushSpaces()
	{
		while (spaces > 0) {
			dgt(" ");
			spaces--;
		}
	}
	while (ln.length > 0) {
		switch (ln[0]) {
		default:
			if (ln[0] == ' ') {
				spaces++;
				ln = ln[1 .. $];
				continue;
			} else if (ln[0] != '\n') {
				flushSpaces();
			}
			if (ln[0] == '\n' && spaces >= 2) {
				dgt("<br />");
				spaces = 0;
			}
			zero: size_t = 0;
			encode(dgt, decode(ln, ref zero));
			ln = ln[zero .. $];
			break;
		case '\\':
			flushSpaces();
			if (ln.length >= 2) {
				switch (ln[1]) {
					default:
						dgt("\\");
						ln = ln[1 .. $];
						break;
					case '\n':
						dgt("<br />\n");
						ln = ln[2 .. $];
						break;
					case '\'', '`', '*', '_', '{', '}', '[', ']',
						'(', ')', '#', '+', '-', '.', '!', '~', '\\':
						encode(dgt, ln[1]);
						ln = ln[2 .. $];
						break;
				}
			} else {
				encode(dgt, ln[0]);
				ln = ln[1 .. $];
			}
			break;
		case '_':
		case '*':
			flushSpaces();
			text: string;
			if (auto em = parseEmphasis(ref ln, ref text)) {
				dgt(em == 1 ? "<em>": em == 2 ? "<strong>": "<strong><em>");
				htmlEscapeIgnoreTags(dgt, text);
				dgt(em == 1 ? "</em>": em == 2 ? "</strong>": "</em></strong>");
			} else {
				encode(dgt, ln[0]);
				ln = ln[1 .. $];
			}
			break;
		case '~':
			flushSpaces();
			if (!(settings.flags & MarkdownFlags.strikeThrough)) {
				goto default;
			}
			strucken: string;
			if (parseStrike(ref ln, ref strucken)) {
				dgt("<del>");
				htmlEscapeIgnoreTags(dgt, strucken);
				dgt("</del>");
			} else {
				encode(dgt, ln[0]);
				ln = ln[1 .. $];
			}
			break;
		case '`':
			flushSpaces();
			code: string;
			if (parseInlineCode(ref ln, ref code)) {
				dgt("<code>");
				htmlEscapeIgnoreTags(dgt, code);
				dgt("</code>");
			} else while (ln.length > 0 && ln[0] == '`') {
				encode(dgt, ln[0]);
				ln = ln[1 .. $];
			}
			break;
		case '[':
			flushSpaces();
			link: Link;
			b: bool = parseLink(ref ln, ref link, linkrefs);
			if (b) {
				dgt("<a href=\"");
				htmlEscape(dgt, filterLink(link.url, false));
				dgt("\"");
				if (link.title.length) {
					dgt(" title=\"");
					htmlEscape(dgt, link.title);
					dgt("\"");
				}
				dgt(">");
				writeMarkdownEscaped(dgt, link.text, linkrefs, settings);
				dgt("</a>");
			} else {
				encode(dgt, ln[0]);
				ln = ln[1 .. $];
			}
			break;
		case '!':
			flushSpaces();
			link: Link;
			if (parseLink(ref ln, ref link, linkrefs)) {
				dgt("<img src=\"");
				htmlEscape(dgt, filterLink(link.url, true));
				dgt("\" alt=\"");
				htmlEscape(dgt, link.text);
				dgt("\"");
				if (link.title.length) {
					dgt(" title=\"");
					htmlEscape(dgt, link.title);
					dgt("\"");
				}
				dgt(">");
			} else if (ln.length >= 2) {
				dgt(ln[0 .. 2]);
				ln = ln[2 .. $];
			} else {
				encode(dgt, ln[0]);
				ln = ln[1 .. $];
			}
			break;
		case '>':
			flushSpaces();
			if (settings.flags & MarkdownFlags.noInlineHtml) dgt("&gt;");
			else encode(dgt, ln[0]);
			ln = ln[1 .. $];
			break;
		case '<':
			flushSpaces();
			url: string;
			if (parseAutoLink(ref ln, ref url)) {
				is_email: bool = url.startsWith("mailto:") != 0;
				dgt("<a href=\"");
				if (is_email) htmlEscapeAll(dgt, url);
				else htmlEscape(dgt, filterLink(url, false));
				dgt("\">");
				if (is_email) htmlEscapeAll(dgt, url[7 .. $]);
				else htmlEscapeIgnoreTags(dgt, url);
				dgt("</a>");
			} else {
				if (ln.startsWith("<br>")) {
					// always support line breaks, since we embed them here ourselves!
					dgt("<br>");
					ln = ln[4 .. $];
				} else {
					if (ln[0] == '<' && ln[$-1] == '>' && !validTag(ln[1 .. $-1])) {
						dgt("&lt;");
						ln = ln[1 .. $];
						while (ln[0] != '>') {
							encode(dgt, ln[0]);
							ln = ln[1 .. $];
						}
						dgt("&gt;");

					} else if (settings.flags & MarkdownFlags.noInlineHtml) dgt("&lt;");
					else encode(dgt, ln[0]);
					ln = ln[1 .. $];
				}
			}
			break;
		}
	}
	if (br) dgt("<br/>");
}

private fn isLineBlank(ln: string) bool {
	return allOf(ln, " \t");
}

private fn isSetextHeaderLine(ln: string, lastLine: Line, leadingSpaces: size_t) bool {
	if (lastLine.type != LineType.Plain || leadingSpaces >= 4 || lastLine.leadingSpaces >= 4) return false;

	ln = stripLeft(ln);
	if (ln.length < 1) return false;
	if (ln[0] == '=') {
		while (ln.length > 0 && ln[0] == '=') ln = ln[1 .. $];
		return allOf(ln, " \t");
	}
	if (ln[0] == '-') {
		while (ln.length > 0 && ln[0] == '-') ln = ln[1 .. $];
		return allOf(ln, " \t");
	}
	return false;
}

private fn isAtxHeaderLine(ln: string, leadingSpaces: size_t) bool {
	if ( leadingSpaces >= 4) return false;
	ln = stripLeft(ln);
	i: size_t = 0;
	while (i < ln.length && ln[i] == '#') i++;
	if (i < 1 || i > 6) return false;
	return i >= ln.length ? true: ln[i] == ' ';
}

private fn isHlineLine(ln: string, leadingSpaces: size_t) bool {
	if (leadingSpaces >= 4) return false;
	if (allOf(ln, " -") && count(ln, '-') >= 3) return true;
	if (allOf(ln, " *") && count(ln, '*') >= 3) return true;
	if (allOf(ln, " _") && count(ln, '_') >= 3) return true;
	return false;
}

private fn isHlineInList(ln: string, leadingSpaces: size_t) bool {
	if (leadingSpaces >= 4) return false;
	if (allOf(ln, " *") && count(ln, '*') >= 3) return true;
	if (allOf(ln, " _") && count(ln, '_') >= 3) return true;
	return false;
}

private fn isQuoteLine(ln: string) bool {
	return ln.stripLeft().startsWith(">") > 0;
}

private fn getQuoteLevel(ln: string) size_t {
	level: size_t = 0;
	ln = stripLeft(ln);
	while (ln.length > 0 && ln[0] == '>') {
		level++;
		ln = stripLeft(ln[1 .. $]);
	}
	return level;
}

private fn isUListLine(ln: string) bool {
	ln = stripLeft(ln);
	if (ln.length < 1) return false;
	if (indexOf("*+-", ln[0]) == -1) return false;
	if (ln.length > 1 && ln[1] != ' ' && ln[1] != '\t') return false;
	return true;
}

private fn isOListLine(ln: string, ref num: string) bool {
	ln = stripLeft(ln);
	if (ln.length < 1) return false;
	if (ln[0] < '0' || ln[0] > '9') return false;
	n: string;
	hitNonZero: bool;
	while (ln.length > 0 && ln[0] >= '0' && ln[0] <= '9') {
		if (ln[0] != '0') {
			hitNonZero = true;
		}
		if (ln[0] != '0' || hitNonZero || (ln.length > 1 && !isDigit(ln[1]))) {
			n = format("%s%s", n, ln[0]);
		}
		ln = ln[1 .. $];
	}
	if (n.length > 9) {
		return false;
	}
	num = n;
	if (ln.length < 1) return false;
	if (ln[0] != '.' && ln[0] != ')') return false;
	if (ln.length > 1 && ln[1] != ' ' && ln[1] != '\t' )
		return false;
	return true;
}

private fn removeListPrefix(str: string, tp: LineType, ref leadingSpace: size_t) string {
	switch (tp) {
		default: assert(false);
		case LineType.OList: // skip bullets and output using normal escaping
			idx := str.indexOf('.');
			if (idx < 0) {
				idx = str.indexOf(")");
			}
			assert(idx > 0);
			s := str[idx+1 .. $];
			leadingSpace = countLeading(s, ' ');
			return s.stripLeft();
		case LineType.UList:
			s := str.stripLeft()[1 .. $];
			leadingSpace = countLeading(s, ' ');
			return s.stripLeft();
	}
}

struct HtmlBlockInfo {
	fullText: string;
	isCommentOpenBlock: bool;
	isCommentCloseBlock: bool;
	closeTag: string;
	isHtmlBlock: bool;
	tagName: string;
	open: bool;
	uniqueBlankTag: bool;
	literalInLine: string;
	indent: string;
}

private fn parseHtmlBlockLine(ln: string, leadingSpaces: size_t = 0) HtmlBlockInfo {
	ret: HtmlBlockInfo;
	ret.fullText = ln;
	ret.isHtmlBlock = false;
	ret.open = true;
	ret.uniqueBlankTag = false;
	if (ln.indexOf("-->") > -1) {
		ret.isHtmlBlock = true;
		ret.isCommentCloseBlock = true;
		ret.closeTag = "<!--";
	}
	if (ln.indexOf("?>") > -1) {
		ret.isHtmlBlock = true;
		ret.isCommentCloseBlock = true;
		ret.closeTag = "<?";
	}
	if (ln.indexOf("]]>") > -1) {
		ret.isHtmlBlock = true;
		ret.isCommentCloseBlock = true;
		ret.closeTag = "<![CDATA[";
	}

	if (leadingSpaces >= 4) {
		return ret;
	}
	ret.indent = "    "[0 .. leadingSpaces];
	ln = strip(ln);
	if (ln.length < 3) return ret;
	if (ln[0] != '<') return ret;
	if (ln[1] == '/') {
		ret.open = false;
		ln = ln[1 .. $];
	}

	if (ln.startsWith("<!--")) {
		ret.isCommentOpenBlock = true;
		ret.isHtmlBlock = true;
		ret.tagName = "<!--";
		return ret;
	}

	if (ln.startsWith("<![CDATA[")) {
		ret.isCommentOpenBlock = true;
		ret.isHtmlBlock = true;
		ret.tagName = "<![CDATA[";
		return ret;
	}

	if (ln.startsWith("<!")) {
		if (ln.length < 3 || ln[2] < 'A' || ln[2] > 'Z') {
			return ret;
		}
		ret.isCommentOpenBlock = true;
		ret.isHtmlBlock = true;
		ret.tagName = "<!";
		return ret;
	}

	if (ln.startsWith("<?")) {
		ret.isCommentOpenBlock = true;
		ret.isHtmlBlock = true;
		ret.tagName = "<?";
		return ret;
	}

	ln = ln[1 .. $];
	idx: size_t = 0;
	while (idx < ln.length && ln[idx] != ' ' && ln[idx] != '>' )
		idx++;
	ret.tagName = ln[0 .. idx];
	ln = ln[idx .. $];

	if (!ret.tagName.validTag()) {
		return ret;
	}

	if (s_literalTags.indexOf(ret.tagName.toLower()) > -1) {
		ret.isHtmlBlock = true;
		openi := ln.indexOf('<');
		if (openi == -1) {
			return ret;
		}
		_body: string = ln[0 .. openi];
		tag := parseHtmlBlockLine(ln[openi .. $]);
		if (tag.isHtmlBlock && tag.tagName == ret.tagName && !tag.open) {
			ret.literalInLine = format("<%s%s</%s>", ret.tagName, _body, tag.tagName);
		}
		return ret;
	}

	if (s_blockTags.indexOf(ret.tagName.toLower()) == -1) {
		eidx := ln.indexOf('>');
		if (eidx < 0) return ret;
		if (eidx != cast(ptrdiff_t)(ln.length-1)) return ret;
		ret.isHtmlBlock = true;
		ret.uniqueBlankTag = true;
		return ret;
	}

	ret.isHtmlBlock = true;
	return ret;
}

private fn validTag(s: string) bool {
	if (s.length == 0) {
		return false;
	}
	foreach (i, c: dchar; s) {
		if (i == 0 && !isAlpha(c)) {
			return false;
		} else if (!isAlpha(c) && !isDigit(c) && c != '-') {
			return false;
		}
	}
	return true;
}

private fn isCodeBlockDelimiter(ln: string, leadingSpaces: size_t) bool {
	if (leadingSpaces >= 4) {
		return false;
	}
	text := ln.strip();
	fence: bool = text.startsWith("```") > 0 || text.startsWith("~~~") > 0;
	if (!fence) {
		return false;
	}

	/* Code fences may not have internal spaces, but they can specify languages.
	 * Go to the end of the first fence, and check for any ` ~ characters after that. */
	if (text.length >= 3) {
		i: size_t = 3;
		while (i < text.length && (text[i] == '`' || text[i] == '~')) {
			i++;
		}
		if (i < text.length) {
			while (i < text.length) {
				if (text[i] == '`' || text[i] == '~') {
					return false;
				}
				i++;
			}
		}
	}

	return true;
}

private fn getHtmlTagName(ln: string) string {
	return parseHtmlBlockLine(ln).tagName;
}

private fn isLineIndented(ln: string) bool {
	return ln.startsWith("\t") || ln.startsWith("    ");
}

private fn unindentLine(ln: string) string {
	if (ln.startsWith("\t")) return ln[1 .. $];
	if (ln.startsWith("    ")) return ln[4 .. $];
	assert(false);
}

private fn parseEmphasis(ref str: string, ref text: string) i32 {
	pstr: string = str;
	if (pstr.length < 3) return false;

	ctag: string;
	if (pstr.startsWith("***")) ctag = "***";
	else if (pstr.startsWith("**")) ctag = "**";
	else if (pstr.startsWith("*")) ctag = "*";
	else if (pstr.startsWith("___")) ctag = "___";
	else if (pstr.startsWith("__")) ctag = "__";
	else if (pstr.startsWith("_")) ctag = "_";
	else return false;

	pstr = pstr[ctag.length .. $];

	/* If the first character is whitespace,
	 * this can't be a left-flanking delimiter run. */
	if (isWhite(pstr[0])) return false;

	fn cidx() ptrdiff_t { return pstr.indexOf(ctag); }
	if (cidx() < 1) return false;

	text = pstr[0 .. cast(size_t)cidx()];

	str = pstr[cast(size_t)cidx()+ctag.length .. $];
	return cast(i32)ctag.length;
}

private fn parseStrike(ref str: string, ref strucken: string) bool {
	pstr: string = str;
	if (pstr.length < 5) {
		return false;
	}
	if (!pstr.startsWith("~~")) {
		return false;
	}
	pstr = pstr[2 .. $];
	fn cidx() ptrdiff_t { return pstr.indexOf("~~"); }
	if (cidx() < 1) {
		return false;
	}

	strucken = pstr[0 .. cast(size_t)cidx()];
	str = pstr[cast(size_t)cidx()+2 .. $];
	return true;
}

private fn parseInlineCode(ref str: string, ref code: string) bool {
	pstr := str;
	if (pstr.length < 3 || pstr[0] != '`') return false;
	ctag: string;
	i: size_t;
	while (pstr[i] == '`') {
		i++;
	}
	ctag = pstr[0 .. i];
	pstr = pstr[ctag.length .. $];

	fn cidx() ptrdiff_t { return pstr.indexOf(ctag); }
	if (cidx() < 1) return false;

	code = pstr[0 .. cast(size_t)cidx()].strip();
	str = pstr[cast(size_t)cidx()+ctag.length .. $];
	return true;
}

private fn restoreQuotes(s: string) string
{
	ss: StringSink;
	foundEscape: bool;
	escapess: StringSink;
	foreach (c: dchar; s) {
		if (foundEscape) {
			if (c == ';') {
				tag: string = escapess.toString();
				if (tag != "quot") {
					ss.sink("&");
					ss.sink(tag);
					ss.sink(";");
				} else {
					ss.sink("\"");
				}
				foundEscape = false;
				continue;
			}
			escapess.sink(encode(c));
			continue;
		}
		if (c != '&') {
			ss.sink(encode(c));
		} else {
			foundEscape = true;
			escapess.reset();
		}
	}
	return ss.toString();
}

private fn parseLink(ref str: string, ref dst: Link, linkrefs: LinkRefs) bool {
	pstr: string = str;
	if (pstr.length < 3) return false;
	// ignore img-link prefix
	if (pstr[0] == '!') pstr = pstr[1 .. $];

	// parse the text part [text]
	if (pstr[0] != '[') return false;
	cidx := pstr.matchBracket();
	if (cidx < 1) return false;
	refid: string;
	dst.text = pstr[1 .. cidx];
	pstr = pstr[cidx+1 .. $];

	// parse either (link '['"title"']') or '[' ']'[refid]
	if (pstr.length > 2 && pstr[0] == '(') {
		cidx = pstr.matchBracket();
		if (cidx < 1) return false;
		inner := pstr[1 .. cidx].restoreQuotes();
		qidx: immutable(ptrdiff_t) = inner.indexOf('"');
		if (qidx > 1 && inner[qidx - 1].isWhite()) {
			dst.url = inner[0 .. qidx].stripRight();
			len: immutable(ptrdiff_t) = inner[qidx .. $].lastIndexOf('"');
			if (len == 0) return false;
			assert(len > 0);
			dst.title = inner[qidx + 1 .. qidx + len];
		} else {
			dst.url = inner.stripRight();
			dst.title = null;
		}
		if (dst.url.startsWith("<") && dst.url.endsWith(">"))
			dst.url = dst.url[1 .. $-1];
		pstr = pstr[cidx+1 .. $];
	} else if (dst.text.length > 0) {
		refid = dst.text;
	} else {
		if (pstr.length < 2) return false;
		if (pstr[0] == ' ') pstr = pstr[1 .. $];
		if (pstr[0] != '[') return false;
		pstr = pstr[1 .. $];
		cidx = pstr.lastIndexOf(']');
		if (cidx < 0) return false;
		if (cidx == 0) refid = dst.text;
		else refid = pstr[0 .. cidx];
		pstr = pstr[cidx+1 .. $];
	}

	if (refid.length > 0) {
		pr := toLower(refid) in linkrefs.ret;
		if (pr is null) {
			return false;
		}
		dst.url = pr.url;
		dst.title = pr.title;
	}

	str = pstr;
	return true;
}

private fn parseAutoLink(ref str: string, ref url: string) bool {
	pstr: string = str;
	if (pstr.length < 3) return false;
	if (pstr[0] != '<') return false;
	pstr = pstr[1 .. $];
	cidx := pstr.indexOf('>');
	if (cidx < 0) return false;
	url = pstr[0 .. cidx];
	if (anyOf(url, " \t")) return false;
	if (!anyOf(url, ":@")) return false;
	str = pstr[cidx+1 .. $];
	if (url.indexOf('@') > 0) url = format("mailto:%s", url);
	return true;
}

private fn urlEscape(s: string, escapeSpaces: bool, escapeSlashes: bool) string
{
	ss: StringSink;
	foreach (c: dchar; s) {
		switch (c) {
		default:
			sss: string = encode(c);
			foreach (cc: char; sss) {
				i := cast(u32) cc;
				if (i <= 127) {
					ss.sink(encode(cc));
				} else {
					ss.sink("%");
					ss.sink(format("%X", i));
				}
			}
			continue;
		case ' ':
			if (!escapeSpaces) {
				goto default;
			}
			ss.sink("%20");
			break;
		case '\\':
			if (!escapeSlashes) {
				goto default;
			}
			ss.sink("%5C");
			break;
		}
	}
	return ss.toString();
}

private class LinkRefs
{
	ret: LinkRef[string];

	fn scanForReferences(ref lines: string[]) {
		reflines: bool[size_t];
		lookingForTitle, lookingForUrl: bool;
		currentRefid, currentUrl: string;
		multilines: size_t[];
		titleChar: char = '?';
		titleBuf: char[];
		startidx: size_t;  // The index this ref started parsing on.
		insertlines: string[size_t];

		fn resetVars()
		{
			currentUrl = currentRefid = "";
			multilines = [];
			lookingForTitle = lookingForUrl = false;
			titleBuf = [];
			titleChar = '?';
		}

		// search for reference definitions:
		//   [refid] link "opt text"
		//   [refid] <link> "opt text"
		//   "opt text", 'opt text', (opt text)
		lnidx: size_t;
		while (lnidx < lines.length) {
			leadingSpaces := countLeading(lines[lnidx], ' ');
			ln: string = stripLeft(lines[lnidx]);
			if (!ln.startsWith("[") && !lookingForUrl && !lookingForTitle) {
				starti := ln.indexOf("[");
				cdatai := ln.indexOf("<![CDATA[");
				if (starti < 0 || cdatai >= 0) {
					lnidx++;
					continue;
				}
				if (starti > 0) {
					insertlines[lnidx] = ln[0 .. starti];
					ln = ln[starti .. $];
				}
			}

			if (!lookingForUrl && !lookingForTitle && lnidx > 0) {
				p := (lnidx-1) in reflines;
				dummy: string;
				if (!lines[lnidx-1].stripLeft().startsWith("[") &&
				    !isAtxHeaderLine(lines[lnidx-1], leadingSpaces) &&
					!isHlineLine(ln, leadingSpaces) &&
					!isOListLine(ln, ref dummy) && !isUListLine(ln) &&
					!isLineBlank(lines[lnidx-1]) &&
					p is null) {
					lnidx++;
					continue;
				}
			}

			if (leadingSpaces >= 4 && !lookingForUrl && !lookingForTitle) {
				lnidx++;
				continue;
			}

			ln = strip(ln);
			if (!ln.startsWith("[") && !lookingForUrl && !lookingForTitle) {
				lnidx++;
				continue;
			}

			if (!lookingForUrl && !lookingForTitle) {
				startidx = lnidx;
				ln = ln[1 .. $];
				fn idx() ptrdiff_t {
					return ln.indexOf("]:");
				}
				refid: string;
				if (idx() < 0) {
					if (ln.indexOf("]") >= 0) {
						lnidx++;
						continue;
					}
					indices: size_t[];
					do {
						indices ~= lnidx;
						lnidx++;
						ln = strip(lines[lnidx]);
						if (ln.indexOf("]") < 0) {
							refid = format("%s%s", refid, ln);
						}
					} while (lnidx < lines.length - 1 && ln.indexOf("]") < 0);
					if (ln.startsWith("]:")) {
						foreach (index; indices) {
							reflines[index] = true;
							reflines[lnidx] = true;
						}
						continue;
					}
				} else {
					refid = ln[0 .. cast(size_t)idx()];
					ln = stripLeft(ln[cast(size_t)idx()+2 .. $]);
				}
				currentRefid = refid;
			} else {
				ln = stripLeft(ln);
			}

			url: string;
			if (!lookingForTitle) {
				if (ln.startsWith("<")) {
					i := ln.indexOf('>');
					if (i < 0) {
						lnidx++;
						continue;
					}
					url = ln[1 .. cast(size_t)i];
					ln = ln[cast(size_t)i+1 .. $];
				} else {
					i := ln.indexOf(' ');
					if (i > 0) {
						url = ln[0 .. cast(size_t)i];
						ln = ln[cast(size_t)i+1 .. $];
					} else {
						i = ln.indexOf('\t');
						if (i < 0) {
							url = ln;
							ln = ln[$ .. $];
						} else {
							url = ln[0 .. cast(size_t)i];
							ln = ln[cast(size_t)i+1 .. $];
						}
					}
				}
				if (strip(url).length == 0) {
					if (lookingForUrl) {
						resetVars();
						lnidx++;
						continue;
					}
					lookingForUrl = true;
					multilines ~= lnidx;
					lnidx++;
					continue;
				} else {
					currentUrl = url;
				}
			}
			ln = stripLeft(ln);

			title: string;
			if (ln.length >= 1 && titleChar == '?') {
				if (ln[0] == '(' || ln[0] == '\"' || ln[0] == '\'') {
					lookingForTitle = true;
					titleChar = ln[0];
					titleBuf = [];
					endi := ln.lastIndexOf(titleChar);
					ln = ln[1 .. $];
					if (ln.length == 0 || ln.stripRight()[$-1] != titleChar) {
						if (endi != 0) {
							title = "";
							lookingForTitle = false;
						} else {
							titleBuf = cast(char[])format("%s%s\n", titleBuf, ln);
							multilines ~= lnidx;
							lnidx++;
							continue;
						}
					}
				}
			}
			if (titleChar == '?' && !lookingForTitle) {
				lookingForTitle = true;
				multilines ~= lnidx;
				if (lnidx < lines.length - 1 && lines[lnidx+1].stripLeft()[0] != '[') {
					lnidx++;
					continue;
				}
			}

			if (titleChar == '?' && lookingForTitle) {
				title = "";
				lookingForTitle = false;
			}

			stripped := ln.stripRight();
			if (stripped.length >= 1 && stripped[$-1] == titleChar) {
				titleBuf = cast(char[])format("%s%s", titleBuf, stripped[0 .. $-1]);
				title = cast(string)titleBuf;
				ln = "";
			} else if (lookingForTitle) {
				if (strip(ln).length != 0) {
					titleBuf = cast(char[])format("%s%s\n", titleBuf, ln);
					multilines ~= lnidx;
					lnidx++;
					continue;
				}
				if (titleBuf.length > 0) {
					resetVars();
					lnidx++;
					continue;
				} else {
					title = "";
				}
			}

			if (strip(ln).length > 0 && startidx == lnidx) {
				/* CommonMark can't make up its mind on whether newlines are
				 * just whitespace or treated differently. In this case, the
				 * main description of link references and the examples don't
				 * match up.
				 *
				 * This catches `[foo]: /url "title" ok` and invalidates the line.
				 * If there's a newline after the url, only the title is invalidated.
				 */
				resetVars();
				lnidx++;
				continue;
			}

			currentUrl = urlEscape(backslashEscape(currentUrl), true, true);
			title = backslashEscape(title);
			lr: LinkRef = {currentRefid, currentUrl, title};
			id := toLower(currentRefid);
			tag := id in ret;
			if (tag is null) {
				ret[toLower(currentRefid)] = lr;
			}
			if (lookingForTitle) {
				multilines ~= lnidx;
			}
			foreach (i; multilines) {
				reflines[i] = true;
			}
			resetVars();
			lnidx++;
		}

		// remove all lines containing references
		nonreflines: string[];
		foreach (i, ln; lines) {
			p := i in reflines;
			pp := i in insertlines;
			if (p is null) {
				nonreflines ~= ln;
			} else if (pp !is null) {
				nonreflines ~= *pp;
			}
		}
		lines = nonreflines;
	}
}

private struct LinkRef {
	id: string;
	url: string;
	title: string;
}

private struct Link {
	text: string;
	url: string;
	title: string;
}
