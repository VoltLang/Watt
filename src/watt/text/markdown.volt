/**
	Markdown parser implementation
	Copyright: © 2012-2015 RejectedSoftware e.K.
	License:
		Boost Software License - Version 1.0 - August 17th, 2003
		Permission is hereby granted, free of charge, to any person or organization
		obtaining a copy of the software and accompanying documentation covered by
		this license (the "Software") to use, reproduce, display, distribute,
		execute, and transmit the Software, and to prepare derivative works of the
		Software, and to permit third-parties to whom the Software is furnished to
		do so, all subject to the following:
		The copyright notices in the Software and this entire statement, including
		the above license grant, this restriction and the following disclaimer,
		must be included in all copies of the Software, in whole or in part, and
		all derivative works of the Software, unless such copies or derivative
		works are solely in the form of machine-executable object code generated by
		a source language processor.
		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
		SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
		FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
		ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
		DEALINGS IN THE SOFTWARE.
	Authors: Sönke Ludwig
*/
module vibe.textfilter.markdown;

import watt.io;  // TODO: Remove
import watt.algorithm : min;
import watt.conv : toString, toLower;
import watt.text.ascii : isAlpha, isWhite, isDigit;
import watt.text.string : splitLines, stripLeft, stripRight, startsWith, strip, join, endsWith, indexOf, count, lastIndexOf;
import watt.text.format : format;
import watt.text.utf : encode, decode;
import watt.text.sink;
import watt.text.html;

/*
	TODO:
		detect inline HTML tags
*/

/// Returns false if str contains a character that's not in chars.
bool allOf(string str, string chars)
{
	foreach (dchar c; str) {
		if (indexOf(chars, c) == -1) {
			return false;
		}
	}
	return true;
}

/// Returns true if str contains any characters in chars.
bool anyOf(string str, string chars)
{
	foreach (dchar c; str) {
		if (indexOf(chars, c) != -1) {
			return true;
		}
	}
	return false;
}

/// Returns how many of chr str starts with.
size_t countLeading(string str, dchar chr)
{
	foreach (i, dchar c; str) {
		if (c != chr) {
			return i;
		}
	}
	return str.length;
}

/// Finds the index of the closing bracket if str starts with [, (, <, or {.
/// -1 on failure.
private ptrdiff_t matchBracket(string str, bool nested = true)
{
	if (str.length < 2) {
		return -1;
	}

	dchar open = str[0], close;
	switch (str[0]) {
	case '[': close = ']'; break;
	case '(': close = ')'; break;
	case '<': close = '<'; break;
	case '{': close = '}'; break;
	default: return -1;
	}

	size_t level = 1;
	bool escape;
	foreach (i, dchar c; str[1 .. $]) {
		if (c == '\\') {
			escape = true;
			continue;
		}
		if (escape && c == close) {
			escape = false;
			continue;
		} else {
			escape = false;
		}
		if (nested && c == open) {
			++level;
		} else if (c == close) {
			--level;
		}
		if (level == 0) {
			return cast(ptrdiff_t)(i + 1);
		}
	}

	return -1;
}


string backslashEscape(string str)
{
	StringSink dst;
	bool next = false;
	foreach (dchar c; str) {
		if (!next && c != '\\') {
			dst.sink(encode(c));
			continue;
		}
		if (!next) {
			next = true;
			continue;
		}
		switch (c) {
		case '!', '\"', '#', '$', '%', '&', '\'', '(', ')', '*',
		     '+', ',', '-', '.', '/', ':', ';', '<', '=', '>',
		     '?', '@', '[', '\\', ']', '^', '_', '`', '{', '|', '}',
			 '~':
			dst.sink(encode(c));
			break;
		default:
			dst.sink("\\");
			dst.sink(encode(c));
			break;
		}
		next = false;
	}
	return dst.toString();
}


/** Returns a Markdown filtered HTML string.
*/
string filterMarkdown(string str, MarkdownFlags flags)
{
	auto settings = new MarkdownSettings();
	settings.flags = flags;
	return filterMarkdown(str, settings);
}
/// ditto
string filterMarkdown(string str, scope MarkdownSettings settings = null) {
	StringSink dst;
	filterMarkdown(dst.sink, str, settings);
	return dst.toString();
}



/** Markdown filters the given string and writes the corresponding HTML to an output range.
*/
void filterMarkdown(Sink dg, string src, MarkdownFlags flags)
{
	auto settings = new MarkdownSettings();
	settings.flags = flags;
	filterMarkdown(dg, src, settings);
}
/// ditto
void filterMarkdown(Sink dg, string src, scope MarkdownSettings settings = null)
{
	auto defsettings = new MarkdownSettings();
	if (settings is null) settings = defsettings;

	auto all_lines = splitLines(src);
	while (all_lines.length > 0 && isLineBlank(all_lines[$-1])) {
		all_lines = all_lines[0 .. $-1];
	}
	auto links = new LinkRefs();
	links.scanForReferences(ref all_lines);
	auto lines = parseLines(ref all_lines, settings);
	Block root_block;
	parseBlocks(ref root_block, ref lines, null, settings);
	writeBlock(dg, ref root_block, links, settings);
}

final class MarkdownSettings {
	/// Controls the capabilities of the parser.
	MarkdownFlags flags = MarkdownFlags.voltDefault;

	/// Heading tags will start at this level.
	size_t headingBaseLevel = 1;

	/// Called for every link/image URL to perform arbitrary transformations.
	string delegate(string url_or_path, bool is_image) urlFilter;
}

enum MarkdownFlags {
	none = 0,
	keepLineBreaks = 1<<0,
	backtickCodeBlocks = 1<<1,
	noInlineHtml = 1<<2,
	//noLinks = 1<<3,
	//allowUnsafeHtml = 1<<4,
	strikeThrough = 1<<5,
	vanillaMarkdown = none,
	forumDefault = keepLineBreaks|backtickCodeBlocks|noInlineHtml,
	voltDefault = backtickCodeBlocks|strikeThrough
}

private {
	global immutable s_blockTags = [
"address", "article", "aside",
"base", "basefont", "blockquote", "body",
"caption", "center", "col", "colgroup",
"dd", "details", "dialog", "dir", "div", "dl", "dt",
"fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset",
"h1", "head", "header", "hr", "html",
"iframe",
"legend", "li", "link",
"main", "menu", "menuitem", "meta",
"nav", "noframes",
"ol", "optgroup", "option",
"p", "param",
"section", "source", "summary",
"table", "tbody", "td", "tfoot", "th", "thead", "title", "track",
"ul"
];

	global immutable s_literalTags = [
"script", "style", "pre"
];
}

private enum IndentType {
	White,
	Quote
}

private enum LineType {
	Undefined,
	Blank,
	Plain,
	Hline,
	AtxHeader,
	SetextHeader,
	UList,
	OList,
	HtmlBlock,
	CodeBlockDelimiter
}

private struct Line {
	LineType type;
	IndentType[] indent;
	string text;
	string unindented;
	HtmlBlockInfo hblock;
	size_t leadingSpaces;
	string listNum;

	string unindent(size_t n) {
		assert(n <= indent.length);
		string ln = text;
		size_t i;
		while (i < n) {
			final switch (indent[i]) {
			case IndentType.White:
				if (ln.startsWith(" \t")) { ln = ln[2 .. $]; i -= 4; continue; }
				else if (ln.startsWith("  \t")) { ln = ln[3 .. $]; i -= 4; continue; }
				else if (ln.startsWith("   \t")) { ln = ln[4 .. $]; i -= 4; continue; }
				else if (ln.startsWith("\t")) { ln = ln[1 .. $]; i -= 4; continue; }
				else ln = ln[1 .. $];
				break;
			case IndentType.Quote:
				ln = ln.stripLeft()[1 .. $].stripLeft();
				break;
			}
			i++;
		}
		return ln;
	}
}

private size_t countOpeningWhitespace(string text)
{
	size_t i;
	while (isWhite(text[i])) {
		i++;
	}
	return i;
}

private string codeUnindent(string text, size_t listSpaces)
{
	if (listSpaces > 0 && text.length >= listSpaces && text[0 .. listSpaces].allOf(" \t")) {
		return codeUnindent(text[listSpaces .. $], 0);
	}
	string s = text;
	if (s.startsWith("\t")) {
		return s[1 .. $];
	}
	if (s.startsWith(" \t")) {
		return s[2 .. $];
	}
	if (s.startsWith("  \t")) {
		return s[3 .. $];
	}
	if (s.startsWith("   \t")) {
		return s[4 .. $];
	}
	if (s.startsWith("    ")) {
		return s[4 .. $];
	}
	// Doesn't denote a code block, but remove it in one.
	if (s.startsWith("   ")) {
		return s[3 .. $];
	}
	if (s.startsWith("  ")) {
		return s[2 .. $];
	}
	if (s.startsWith(" ")) {
		return s[1 .. $];
	}
	return s;
}

private bool isCode(string text, size_t leadingSpaces)
{
	string s = text;
	if (text.length <= leadingSpaces) {
		return false;
	}
	if (leadingSpaces > 0 && !s[0 .. leadingSpaces].allOf(" \t")) {
		return false;
	}
	s = s[leadingSpaces .. $];
	if (s.length > 2 && s.startsWith("> ")) {
		s = s[2 .. $];
	}
	if (s.startsWith("\t")) {
		return true;
	}
	if (s.startsWith(" \t")) {
		return true;
	}
	if (s.startsWith("  \t")) {
		return true;
	}
	if (s.startsWith("   \t")) {
		return true;
	}
	if (s.startsWith("    ")) {
		return true;
	}
	return false;
}

private Line[] parseLines(ref string[] lines, scope MarkdownSettings settings) {
	Line[] ret;
	for (size_t i = 0; i < lines.length; ++i) {
		auto ln = lines[i];

		Line lninfo;
		lninfo.leadingSpaces = countLeading(ln, ' ');
		lninfo.text = ln;
		lninfo.type = LineType.Plain;

		while (ln.length > 0) {
			void codeIndent()
			{
				foreach (j; 0 .. 4) {
					lninfo.indent ~= IndentType.White;
				}
			}

			if (ln.startsWith("   \t")) {
				codeIndent();
				ln = ln[4 .. $];
			} else if (ln.startsWith(" \t")) {
				codeIndent();
				ln = ln[2 .. $];
			} else if (ln.startsWith("  \t")) {
				codeIndent();
				ln = ln[3 .. $];
			} else if (ln.startsWith("\t")) {
				codeIndent();
				ln = ln[1 .. $];
			} else if (ln.startsWith(" ")) {
				lninfo.indent ~= IndentType.White;
				ln = ln[1 .. $];
			} else {
				ln = ln.stripLeft();
				if (ln.startsWith(">")) {
					lninfo.indent ~= IndentType.Quote;
					ln = ln[1 .. $];
					ln = ln.stripLeft();
				} else {
					break;
				}
			}
		}
		lninfo.unindented = ln;

		if ((settings.flags & MarkdownFlags.backtickCodeBlocks) && isCodeBlockDelimiter(ln, lninfo.leadingSpaces)) lninfo.type = LineType.CodeBlockDelimiter;
		else if (isAtxHeaderLine(ln, lninfo.leadingSpaces)) lninfo.type = LineType.AtxHeader;
		else if (ret.length > 0 && isSetextHeaderLine(ln, ret[$-1], lninfo.leadingSpaces)) lninfo.type = LineType.SetextHeader;
		else if (isHlineLine(ln, lninfo.leadingSpaces)) lninfo.type = LineType.Hline;
		else if (isOListLine(ln, ref lninfo.listNum)) lninfo.type = LineType.OList;
		else if (isUListLine(ln)) lninfo.type = LineType.UList;
		else if (isLineBlank(ln)) lninfo.type = LineType.Blank;
		else {
			auto hblock = parseHtmlBlockLine(ln, lninfo.leadingSpaces);
			if (!(settings.flags & MarkdownFlags.noInlineHtml) && hblock.isHtmlBlock) {
				lninfo.type = LineType.HtmlBlock;
				lninfo.hblock = parseHtmlBlockLine(ln, lninfo.leadingSpaces);
			}
		}

		ret ~= lninfo;
	}
	return ret;
}

private enum BlockType {
	Plain,
	Text,
	Paragraph,
	Header,
	OList,
	UList,
	ListItem,
	Code,
	Quote
}

private enum HtmlEnd {
	Literal,  // </script> </pre> </style>
	CloseTag,
	Condition,  // ?>
	Greater,  // >
	Cdata,  //]]>
	BlankLine,
}

private struct Block {
	BlockType type;
	string[] text;
	Block[] blocks;
	size_t headerLevel;
	string classTag;
	string listNum;
}

private void parseBlocks(ref Block root, ref Line[] lines, IndentType[] base_indent, scope MarkdownSettings settings, bool list=false)
{
	bool hasQuote(IndentType[] itypes)
	{
		foreach (itype; itypes) {
			if (itype == IndentType.Quote) {
				return true;
			}
		}
		return false;
	}

	if (base_indent.length == 0) root.type = BlockType.Text;
	else if (base_indent[$-1] == IndentType.Quote) root.type = BlockType.Quote;

	bool skipEmptyBlockQuote;
	size_t blankSkips;
	while (lines.length > 0) {
		auto ln = lines[0];

		if (ln.type == LineType.Blank) {
			bool quoteNext = lines.length > 1 && lines[1].indent.hasQuote();
			if (!quoteNext && ln.indent.hasQuote() && !skipEmptyBlockQuote) {
				// Empty quote.
				Block b;
				b.type = BlockType.Plain;
				b.text ~= ["<blockquote></blockquote>"];
				root.blocks ~= b;
				skipEmptyBlockQuote = true;
			} else {
				skipEmptyBlockQuote = false;
			}
			if (root.type == BlockType.Quote && !ln.indent.hasQuote()) {
				return;
			}
			blankSkips++;
			if (list && blankSkips >= 2) {
				return;
			}
			lines = lines[1 .. $];
			continue;
		}
		skipEmptyBlockQuote = false;

		size_t l = base_indent.length >= 4 ? base_indent.length : cast(size_t)0;
		if (list) {
			l += 4;
		}
		if (ln.text.isCode(l)) {
			Block cblock;
			Block qblock;
			bool isQuote;
			if (ln.text.startsWith("> ") || ln.unindented.startsWith("> ")) {
				isQuote = true;
				qblock.type = BlockType.Quote;
			}
			cblock.type = BlockType.Code;
			Line[] blanklines;
			bool reContinue;
			while (lines.length > 0 && (lines[0].text.isCode(l) || lines[0].type == LineType.Blank )) {
				if (lines[0].indent.hasQuote() && lines[0].text.length >= l + 2) {
					lines[0].text = lines[0].text[l + 2 .. $];
				}
				if (lines[0].type == LineType.Blank) {
					blanklines ~= lines[0];
					lines = lines[1 .. $];
					continue;
				}
				foreach (bline; blanklines) {
					cblock.text ~= bline.text.codeUnindent(l);
				}
				blanklines = [];
				cblock.text ~= lines[0].text.codeUnindent(l);
				lines = lines[1 .. $];
				if (lines.length > 0 && (!lines[0].text.isCode(l) && lines[0].type != LineType.Blank)) {
					break;
				}
				if (lines.length > 0 && isQuote && !lines[0].text.startsWith("> ")) {
					reContinue = true;
					break;
				}
			}
			if (!isQuote) {
				root.blocks ~= cblock;
			} else {
				qblock.blocks ~= cblock;
				root.blocks ~= qblock;
			}
			if (reContinue) {
				continue;
			}
			if (lines.length == 0) {
				return;
			}
			ln = lines[0];
		}

		// Give how much indent a line has. This is different to ln.indent, as it includes white space after quote indent.
		size_t lineIndent(string s)
		{
			size_t i;
			foreach (dchar c; s) {
				bool breakNow;
				switch (c) {
				case ' ': i++; break;
				case '>': i++; break;
				default: breakNow = true; break;
				}
				if (breakNow) {
					break;
				}
			}
			return i;
		}

		if (list && lineIndent(ln.text) >= base_indent.length && ln.type != LineType.UList && ln.type != LineType.OList && hasQuote(base_indent)) {
		} else if (ln.indent != base_indent) {
			if (ln.indent.length < base_indent.length || ln.indent[0 .. base_indent.length] != base_indent )
				return;

			auto cindent = base_indent ~ [IndentType.White, IndentType.White, IndentType.White, IndentType.White];
			if (ln.indent != cindent || list) {
				Block subblock;
				parseBlocks(ref subblock, ref lines, ln.indent[0 .. base_indent.length+1], settings, list);
				root.blocks ~= subblock;
				continue;
			} else if (!isCode(ln.text, base_indent.length)) {
				continue;
			}
		}
		Block b, subblock;
		bool subblockappend;
		final switch (ln.type) {
		case LineType.Undefined: assert(false);
		case LineType.Blank: assert(false);
		case LineType.Plain:
			if (ln.indent.length > 0 && ln.indent[0] == IndentType.Quote) {
				skipEmptyBlockQuote = true;
			}
			if (lines.length >= 2 && lines[1].type == LineType.SetextHeader &&
				(ln.indent.length == 0 || ln.indent[0] != IndentType.Quote)) {
				if (ln.unindented.startsWith("\\>")) {
					ln.unindented = ln.unindented[1 .. $];
				}
				auto setln = lines[1].unindented;
				b.type = BlockType.Header;
				b.text = [htmlEscapeIgnoreTags(ln.unindented.stripRight())];
				b.headerLevel = setln.strip()[0] == '=' ? 1 : 2;
				lines = lines[2 .. $];
			} else {
				b.type = BlockType.Paragraph;
				b.text = skipText(ref lines, base_indent);
			}
			break;
		case LineType.Hline:
			b.type = BlockType.Plain;
			b.text = ["<hr />"];
			lines = lines[1 .. $];
			break;
		case LineType.AtxHeader:
			b.type = BlockType.Header;
			string hl = ln.unindented;
			b.headerLevel = 0;
			while (hl.length > 0 && hl[0] == '#') {
				b.headerLevel++;
				hl = hl[1 .. $];
			}

			hl = hl.stripRight();
			size_t endi = hl.length - 1;
			while (endi > 0 && (hl[endi] == '#' || isWhite(hl[endi]))) {
				endi--;
			}
			endi++;
			if (hl.length > 0 && isWhite(hl[0]) && endi == 1) {
				hl = "";
			} else if ( isWhite(hl[endi])) {
				hl = hl[0 .. endi];
			}

			b.text = [hl];
			lines = lines[1 .. $];
			break;
		case LineType.SetextHeader:
			if (allOf(lines[0].text, "- \t")) {
				goto case LineType.Hline;
			} else if (root.blocks.length > 0 && root.blocks[$-1].type == BlockType.Paragraph) {
				root.blocks[$-1].text ~= ln.text;
				lines = lines[1 .. $];
			}
			break;
		case LineType.UList:
		case LineType.OList:
			b.type = ln.type == LineType.UList ? BlockType.UList : BlockType.OList;
			if (b.type == BlockType.OList) {
				b.listNum = ln.listNum;
			}
			auto itemindent = base_indent;
			bool trailing;
			auto s = ln.unindent(base_indent.length);
			foreach (dchar c; s) {
				if (isWhite(c)) {
					if (trailing) {
						itemindent ~= IndentType.White;
					}
				} else {
					if (!trailing) {
						trailing = true;
					} else {
						break;
					}
				}
			}
			if (b.type == BlockType.UList || b.type == BlockType.OList) {
				itemindent ~= IndentType.White;
			}
			size_t quotes(IndentType[] indents)
			{
				size_t qcount;
				foreach (indent; indents) {
					if (indent == IndentType.Quote) {
						qcount++;
					}
				}
				return qcount;
			}
			while (lines.length > 0 && lines[0].type == ln.type && lines[0].indent == base_indent) {
				Block itm;
				itm.text = skipText(ref lines, itemindent);
				size_t leadingSpace;
				itm.text[0] = removeListPrefix(itm.text[0], ln.type, ref leadingSpace);
				if ( isHlineInList(itm.text[0], leadingSpace)) {
					itm.text[0] = "<hr />";
				}
				if (lines.length > 1 && quotes(ln.indent) > 0
				    && quotes(ln.indent) == quotes(lines[1].indent) &&
				    lines[1].indent.length >= itemindent.length) {
					subblock.type = BlockType.Paragraph;
					subblock.text = [lines[1].unindent(lines[1].indent.length)];
					lines = lines[2 .. $];
					subblockappend = true;
				}

				if (!subblockappend) {
					size_t oldLength = itm.blocks.length;
					parseBlocks(ref itm, ref lines, itemindent, settings, true);
					size_t newLength = itm.blocks.length;
					if (newLength > oldLength) {
						Block para;
						para.type = BlockType.Paragraph;
						para.text = itm.text;
						itm.blocks = para ~ itm.blocks;
						itm.text = null;
					}
				}
				itm.type = BlockType.ListItem;
				b.blocks ~= itm;
			}
			break;
		case LineType.HtmlBlock:
			int nestlevel = 0;
			auto starttag = ln.hblock;
			HtmlEnd end;
			if (!starttag.isHtmlBlock) {
				break;
			} else if (!starttag.open) {
				end = HtmlEnd.BlankLine;
			}

			if (s_literalTags.indexOf(starttag.tagName.toLower()) > -1) {
				end = HtmlEnd.Literal;
			} else if (s_blockTags.indexOf(starttag.tagName.toLower()) > -1 || starttag.uniqueBlankTag) {
				end = HtmlEnd.BlankLine;
			}
			b.type = BlockType.Plain;
			if (starttag.literalInLine.length > 0) {
				b.text ~= starttag.literalInLine;
				lines = lines[1 .. $];
				break;
			}
			if (starttag.isCommentOpenBlock) {
				end = HtmlEnd.CloseTag;
				if (starttag.isCommentCloseBlock && starttag.tagName == starttag.closeTag) {
					b.text ~= starttag.indent ~ starttag.fullText;
					lines = lines[1 .. $];
					break;
				}
			}
			while (lines.length > 0) {
				if (lines[0].indent.length < base_indent.length) break;
				if (lines[0].indent[0 .. base_indent.length] != base_indent) break;
				auto str = lines[0].unindent(base_indent.length);
				auto taginfo = parseHtmlBlockLine(str);
				b.text ~= taginfo.indent ~ lines[0].unindent(base_indent.length);
				lines = lines[1 .. $];
				if (taginfo.isHtmlBlock && taginfo.tagName == starttag.tagName )
					nestlevel += taginfo.open ? 1 : -1;
				if (taginfo.isHtmlBlock && end == HtmlEnd.Literal &&
					taginfo.tagName.toLower() == starttag.tagName.toLower() &&
					!taginfo.open) {
					break;
				}
				if (starttag.tagName == "<!" && lines[0].text.indexOf('>') > -1) {
					break;
				}
				if (starttag.isCommentOpenBlock && taginfo.isCommentCloseBlock && starttag.tagName == taginfo.closeTag) {
					break;
				}
				if (end != HtmlEnd.BlankLine && nestlevel <= 0) break;
				if (end == HtmlEnd.BlankLine && lines[0].type == LineType.Blank) break;
			}
			break;
		case LineType.CodeBlockDelimiter:
			size_t tilde = ln.text.count('~');
			size_t backt = ln.text.count('`');
			assert((tilde == 0 && backt > 0) || (tilde > 0 && backt == 0));

			// Get language from line if present.
			size_t a;
			if (tilde > 0) {
				a = cast(size_t)ln.text.indexOf('~');
			} else {
				a = cast(size_t)ln.text.indexOf('`');
			}

			while (a < ln.text.length && (ln.text[a] == '`' || ln.text[a] == '~' || isWhite(ln.text[a]))) {
				a++;
			}

			size_t bi = a;
			while (bi < ln.text.length && !isWhite(ln.text[bi])) {
				bi++;
			}

			string lang = ln.text[a .. bi];
			if (lang.length > 0 && lang.count('~') == 0 && lang.count('`') == 0) {
					b.classTag = "language-" ~ lang;
			}

			lines = lines[1 .. $];
			b.type = BlockType.Code;
			while (lines.length != 0) {
				if (hasQuote(base_indent) && !hasQuote(lines[0].indent)) {
					break;
				}
				if (lines[0].type == LineType.CodeBlockDelimiter) {
					if ((tilde > 0 && lines[0].text.count('~') >= tilde && allOf(lines[0].text, "~ \t")) ||
						 backt > 0 && lines[0].text.count('`') >= backt && allOf(lines[0].text, "` \t")) {
						lines = lines[1 .. $];
						break;
					}
				}
				b.text ~= lines[0].unindent(lines[0].indent.length < base_indent.length ? lines[0].indent.length : base_indent.length);
				lines = lines[1 .. $];
			}
			break;
		}
		root.blocks ~= b;
		if (subblockappend) {
			root.blocks ~= subblock;
		}
	}
}

private string[] skipText(ref Line[] lines, IndentType[] indent) {
	static bool matchesIndent(IndentType[] indent, IndentType[] base_indent)
	{
		if (indent.length > base_indent.length) return false;
		if (indent != base_indent[0 .. indent.length]) return false;
		ptrdiff_t qidx = -1;
		foreach_reverse (i, tp; base_indent) if (tp == IndentType.Quote) { qidx = cast(ptrdiff_t)i; break; }
		if (qidx >= 0) {
			qidx = cast(ptrdiff_t)(base_indent.length-1) - qidx;
			if (cast(ptrdiff_t)indent.length <= qidx) return false;
		}
		return true;
	}

	string[] ret;

	bool wasQuote = lines[0].indent.length > 0 && lines[0].indent[0] == IndentType.Quote;
	while (true) {
		ret ~= htmlEscapeIgnoreTags(lines[0].unindent(min(indent.length, lines[0].indent.length)));
		lines = lines[1 .. $];

		if (lines.length > 0) {
			HtmlBlockInfo tag = parseHtmlBlockLine(lines[0].text);
			if (tag.uniqueBlankTag )
				continue;
		}

		if (lines.length == 0 || (lines[0].type != LineType.Plain && !(lines[0].type == LineType.UList && lines[0].text.countLeading(' ') >= 4)) || (lines[0].indent.length > 0 && lines[0].indent[0] == IndentType.Quote && !wasQuote))
			return ret;
	}
	assert(false);
}

/// private
private void writeBlock(Sink dg, ref const Block block, LinkRefs links, scope MarkdownSettings settings, bool fromOrdered = false)
{
	final switch (block.type) {
	case BlockType.Plain:
		foreach( ln; block.text) {
			dg(ln);
			dg("\n");
		}
		foreach(b; block.blocks)
			writeBlock(dg, ref b, links, settings, fromOrdered);
		break;
	case BlockType.Text:
		writeMarkdownEscaped(dg, ref block, links, settings);
		foreach(b; block.blocks)
			writeBlock(dg, ref b, links, settings, fromOrdered);
		break;
	case BlockType.Paragraph:
		assert(block.blocks.length == 0);
		dg("<p>");
		writeMarkdownEscaped(dg, ref block, links, settings);
		dg("</p>\n");
		break;
	case BlockType.Header:
		assert(block.blocks.length == 0);
		auto hlvl = block.headerLevel + (settings ? settings.headingBaseLevel-1 : cast(size_t)0);
		dg(format("<h%s>", hlvl));
		assert(block.text.length == 1);
		writeMarkdownEscaped(dg, ref block.text[0], links, settings);
		dg(format("</h%s>\n", hlvl));
		break;
	case BlockType.OList:
		if (block.listNum != "1" && !fromOrdered) {
			dg("<ol start=\"" ~ block.listNum ~ "\">");
		} else {
			dg("<ol>\n");
		}
		foreach(b; block.blocks)
			writeBlock(dg, ref b, links, settings, true);
		dg("</ol>\n");
		break;
	case BlockType.UList:
		dg("<ul>\n");
		foreach(b; block.blocks)
			writeBlock(dg, ref b, links, settings, fromOrdered);
		dg("</ul>\n");
		break;
	case BlockType.ListItem:
		dg("<li>");
		writeMarkdownEscaped(dg, ref block, links, settings);
		foreach(b; block.blocks)
			writeBlock(dg, ref b, links, settings, fromOrdered);
		dg("</li>\n");
		break;
	case BlockType.Code:
		assert(block.blocks.length == 0);
		if (block.classTag.length > 0) {
			dg("<pre><code class=\"" ~ block.classTag ~ "\">");
		} else {
			dg("<pre><code>");
		}
		foreach(ln; block.text) {
			htmlEscape(dg, ln);
			dg("\n");
		}
		dg("</code></pre>");
		break;
	case BlockType.Quote:
		dg("<blockquote>");
		writeMarkdownEscaped(dg, ref block, links, settings);
		foreach(b; block.blocks) {
			writeBlock(dg, ref b, links, settings, fromOrdered);
		}
		dg("</blockquote>\n");
		break;
	}
}

private void writeMarkdownEscaped(Sink dg, ref const Block block, in LinkRefs links, scope MarkdownSettings settings)
{
	auto lines = cast(string[])block.text;
	auto text = settings.flags & MarkdownFlags.keepLineBreaks ? lines.join("<br>") : lines.join("\n");
	writeMarkdownEscaped(dg, text, links, settings);
	if (lines.length) dg("\n");
}

/// private
private void writeMarkdownEscaped(Sink dg, string ln, LinkRefs linkrefs, scope MarkdownSettings settings)
{
	string filterLink(string lnk, bool is_image) {
		return settings.urlFilter !is null ? settings.urlFilter(lnk, is_image) : lnk;
	}

	ln = ln.strip();
	bool br = ln.endsWith("  ") != 0;
	size_t spaces;
	void flushSpaces()
	{
		while (spaces > 0) {
			dg(" ");
			spaces--;
		}
	}
	while (ln.length > 0) {
		switch (ln[0]) {
		default:
			if (ln[0] == ' ') {
				spaces++;
				ln = ln[1 .. $];
				continue;
			} else if (ln[0] != '\n') {
				flushSpaces();
			}
			if (ln[0] == '\n' && spaces >= 2) {
				dg("<br />");
				spaces = 0;
			}
			size_t zero = 0;
			encode(dg, decode(ln, ref zero));
			ln = ln[zero .. $];
			break;
		case '\\':
			flushSpaces();
			if (ln.length >= 2) {
				switch (ln[1]) {
					default:
						dg("\\");
						ln = ln[1 .. $];
						break;
					case '\n':
						dg("<br />\n");
						ln = ln[2 .. $];
						break;
					case '\'', '`', '*', '_', '{', '}', '[', ']',
						'(', ')', '#', '+', '-', '.', '!', '~', '\\':
						encode(dg, ln[1]);
						ln = ln[2 .. $];
						break;
				}
			} else {
				encode(dg, ln[0]);
				ln = ln[1 .. $];
			}
			break;
		case '_':
		case '*':
			flushSpaces();
			string text;
			if (auto em = parseEmphasis(ref ln, ref text)) {
				dg(em == 1 ? "<em>" : em == 2 ? "<strong>" : "<strong><em>");
				htmlEscapeIgnoreTags(dg, text);
				dg(em == 1 ? "</em>" : em == 2 ? "</strong>": "</em></strong>");
			} else {
				encode(dg, ln[0]);
				ln = ln[1 .. $];
			}
			break;
		case '~':
			flushSpaces();
			if (!(settings.flags & MarkdownFlags.strikeThrough)) {
				goto default;
			}
			string strucken;
			if (parseStrike(ref ln, ref strucken)) {
				dg("<del>");
				htmlEscapeIgnoreTags(dg, strucken);
				dg("</del>");
			} else {
				encode(dg, ln[0]);
				ln = ln[1 .. $];
			}
			break;
		case '`':
			flushSpaces();
			string code;
			if (parseInlineCode(ref ln, ref code)) {
				dg("<code>");
				htmlEscapeIgnoreTags(dg, code);
				dg("</code>");
			} else while (ln.length > 0 && ln[0] == '`') {
				encode(dg, ln[0]);
				ln = ln[1 .. $];
			}
			break;
		case '[':
			flushSpaces();
			Link link;
			bool b = parseLink(ref ln, ref link, linkrefs);
			if (b) {
				dg("<a href=\"");
				htmlEscape(dg, filterLink(link.url, false));
				dg("\"");
				if (link.title.length) {
					dg(" title=\"");
					htmlEscape(dg, link.title);
					dg("\"");
				}
				dg(">");
				writeMarkdownEscaped(dg, link.text, linkrefs, settings);
				dg("</a>");
			} else {
				encode(dg, ln[0]);
				ln = ln[1 .. $];
			}
			break;
		case '!':
			flushSpaces();
			Link link;
			if (parseLink(ref ln, ref link, linkrefs)) {
				dg("<img src=\"");
				htmlEscape(dg, filterLink(link.url, true));
				dg("\" alt=\"");
				htmlEscape(dg, link.text);
				dg("\"");
				if (link.title.length) {
					dg(" title=\"");
					htmlEscape(dg, link.title);
					dg("\"");
				}
				dg(">");
			} else if (ln.length >= 2) {
				dg(ln[0 .. 2]);
				ln = ln[2 .. $];
			} else {
				encode(dg, ln[0]);
				ln = ln[1 .. $];
			}
			break;
		case '>':
			flushSpaces();
			if (settings.flags & MarkdownFlags.noInlineHtml) dg("&gt;");
			else encode(dg, ln[0]);
			ln = ln[1 .. $];
			break;
		case '<':
			flushSpaces();
			string url;
			if (parseAutoLink(ref ln, ref url)) {
				bool is_email = url.startsWith("mailto:") != 0;
				dg("<a href=\"");
				if (is_email) htmlEscapeAll(dg, url);
				else htmlEscape(dg, filterLink(url, false));
				dg("\">");
				if (is_email) htmlEscapeAll(dg, url[7 .. $]);
				else htmlEscapeIgnoreTags(dg, url);
				dg("</a>");
			} else {
				if (ln.startsWith("<br>")) {
					// always support line breaks, since we embed them here ourselves!
					dg("<br>");
					ln = ln[4 .. $];
				} else {
					if (ln[0] == '<' && ln[$-1] == '>' && !validTag(ln[1 .. $-1])) {
						dg("&lt;");
						ln = ln[1 .. $];
						while (ln[0] != '>') {
							encode(dg, ln[0]);
							ln = ln[1 .. $];
						}
						dg("&gt;");

					} else if (settings.flags & MarkdownFlags.noInlineHtml) dg("&lt;");
					else encode(dg, ln[0]);
					ln = ln[1 .. $];
				}
			}
			break;
		}
	}
	if (br) dg("<br/>");
}

private bool isLineBlank(string ln) {
	return allOf(ln, " \t");
}

private bool isSetextHeaderLine(string ln, Line lastLine, size_t leadingSpaces) {
	if (lastLine.type != LineType.Plain || leadingSpaces >= 4 || lastLine.leadingSpaces >= 4) return false;

	ln = stripLeft(ln);
	if (ln.length < 1) return false;
	if (ln[0] == '=') {
		while (ln.length > 0 && ln[0] == '=') ln = ln[1 .. $];
		return allOf(ln, " \t");
	}
	if (ln[0] == '-') {
		while (ln.length > 0 && ln[0] == '-') ln = ln[1 .. $];
		return allOf(ln, " \t");
	}
	return false;
}

private bool isAtxHeaderLine(string ln, size_t leadingSpaces) {
	if ( leadingSpaces >= 4) return false;
	ln = stripLeft(ln);
	size_t i = 0;
	while (i < ln.length && ln[i] == '#') i++;
	if (i < 1 || i > 6) return false;
	return i >= ln.length ? true : ln[i] == ' ';
}

private bool isHlineLine(string ln, size_t leadingSpaces) {
	if (leadingSpaces >= 4) return false;
	if (allOf(ln, " -") && count(ln, '-') >= 3) return true;
	if (allOf(ln, " *") && count(ln, '*') >= 3) return true;
	if (allOf(ln, " _") && count(ln, '_') >= 3) return true;
	return false;
}

private bool isHlineInList(string ln, size_t leadingSpaces) {
	if (leadingSpaces >= 4) return false;
	if (allOf(ln, " *") && count(ln, '*') >= 3) return true;
	if (allOf(ln, " _") && count(ln, '_') >= 3) return true;
	return false;
}

private bool isQuoteLine(string ln) {
	return ln.stripLeft().startsWith(">") > 0;
}

private size_t getQuoteLevel(string ln) {
	size_t level = 0;
	ln = stripLeft(ln);
	while (ln.length > 0 && ln[0] == '>') {
		level++;
		ln = stripLeft(ln[1 .. $]);
	}
	return level;
}

private bool isUListLine(string ln) {
	ln = stripLeft(ln);
	if (ln.length < 1) return false;
	if (indexOf("*+-", ln[0]) == -1) return false;
	if (ln.length > 1 && ln[1] != ' ' && ln[1] != '\t') return false;
	return true;
}

private bool isOListLine(string ln, ref string num) {
	ln = stripLeft(ln);
	if (ln.length < 1) return false;
	if (ln[0] < '0' || ln[0] > '9') return false;
	string n;
	bool hitNonZero;
	while (ln.length > 0 && ln[0] >= '0' && ln[0] <= '9') {
		if (ln[0] != '0') {
			hitNonZero = true;
		}
		if (ln[0] != '0' || hitNonZero || (ln.length > 1 && !isDigit(ln[1]))) {
			n ~= ln[0];
		}
		ln = ln[1 .. $];
	}
	if (n.length > 9) {
		return false;
	}
	num = n;
	if (ln.length < 1) return false;
	if (ln[0] != '.' && ln[0] != ')') return false;
	if (ln.length > 1 && ln[1] != ' ' && ln[1] != '\t' )
		return false;
	return true;
}

private string removeListPrefix(string str, LineType tp, ref size_t leadingSpace) {
	switch (tp) {
		default: assert(false);
		case LineType.OList: // skip bullets and output using normal escaping
			auto idx = str.indexOf('.');
			if (idx < 0) {
				idx = str.indexOf(")");
			}
			assert(idx > 0);
			auto s = str[idx+1 .. $];
			leadingSpace = countLeading(s, ' ');
			return s.stripLeft();
		case LineType.UList:
			auto s = str.stripLeft()[1 .. $];
			leadingSpace = countLeading(s, ' ');
			return s.stripLeft();
	}
}

struct HtmlBlockInfo {
	string fullText;
	bool isCommentOpenBlock;
	bool isCommentCloseBlock;
	string closeTag;
	bool isHtmlBlock;
	string tagName;
	bool open;
	bool uniqueBlankTag;
	string literalInLine;
	string indent;
}

private HtmlBlockInfo parseHtmlBlockLine(string ln, size_t leadingSpaces=0) {
	HtmlBlockInfo ret;
	ret.fullText = ln;
	ret.isHtmlBlock = false;
	ret.open = true;
	ret.uniqueBlankTag = false;
	if (ln.indexOf("-->") > -1) {
		ret.isHtmlBlock = true;
		ret.isCommentCloseBlock = true;
		ret.closeTag = "<!--";
	}
	if (ln.indexOf("?>") > -1) {
		ret.isHtmlBlock = true;
		ret.isCommentCloseBlock = true;
		ret.closeTag = "<?";
	}
	if (ln.indexOf("]]>") > -1) {
		ret.isHtmlBlock = true;
		ret.isCommentCloseBlock = true;
		ret.closeTag = "<![CDATA[";
	}

	if (leadingSpaces >= 4) {
		return ret;
	}
	ret.indent = "    "[0 .. leadingSpaces];
	ln = strip(ln);
	if (ln.length < 3) return ret;
	if (ln[0] != '<') return ret;
	if (ln[1] == '/') {
		ret.open = false;
		ln = ln[1 .. $];
	}

	if (ln.startsWith("<!--")) {
		ret.isCommentOpenBlock = true;
		ret.isHtmlBlock = true;
		ret.tagName = "<!--";
		return ret;
	}

	if (ln.startsWith("<![CDATA[")) {
		ret.isCommentOpenBlock = true;
		ret.isHtmlBlock = true;
		ret.tagName = "<![CDATA[";
		return ret;
	}

	if (ln.startsWith("<!")) {
		if (ln.length < 3 || ln[2] < 'A' || ln[2] > 'Z') {
			return ret;
		}
		ret.isCommentOpenBlock = true;
		ret.isHtmlBlock = true;
		ret.tagName = "<!";
		return ret;
	}

	if (ln.startsWith("<?")) {
		ret.isCommentOpenBlock = true;
		ret.isHtmlBlock = true;
		ret.tagName = "<?";
		return ret;
	}

	ln = ln[1 .. $];
	size_t idx = 0;
	while (idx < ln.length && ln[idx] != ' ' && ln[idx] != '>' )
		idx++;
	ret.tagName = ln[0 .. idx];
	ln = ln[idx .. $];

	if (!ret.tagName.validTag()) {
		return ret;
	}

	if (s_literalTags.indexOf(ret.tagName.toLower()) > -1) {
		ret.isHtmlBlock = true;
		auto openi = ln.indexOf('<');
		if (openi == -1) {
			return ret;
		}
		string _body = ln[0 .. openi];
		auto tag = parseHtmlBlockLine(ln[openi .. $]);
		if (tag.isHtmlBlock && tag.tagName == ret.tagName && !tag.open) {
			ret.literalInLine = "<" ~ ret.tagName ~ _body ~ "</" ~ tag.tagName ~ ">";
		}
		return ret;
	}

	if (s_blockTags.indexOf(ret.tagName.toLower()) == -1) {
		auto eidx = ln.indexOf('>');
		if (eidx < 0) return ret;
		if (eidx != cast(ptrdiff_t)(ln.length-1)) return ret;
		ret.isHtmlBlock = true;
		ret.uniqueBlankTag = true;
		return ret;
	}

	ret.isHtmlBlock = true;
	return ret;
}

private bool validTag(string s) {
	if (s.length == 0) {
		return false;
	}
	foreach (i, dchar c; s) {
		if (i == 0 && !isAlpha(c)) {
			return false;
		} else if (!isAlpha(c) && !isDigit(c) && c != '-') {
			return false;
		}
	}
	return true;
}

private bool isCodeBlockDelimiter(string ln, size_t leadingSpaces) {
	if (leadingSpaces >= 4) {
		return false;
	}
	auto text = ln.strip();
	bool fence = text.startsWith("```") > 0 || text.startsWith("~~~") > 0;
	if (!fence) {
		return false;
	}

	/* Code fences may not have internal spaces, but they can specify languages.
	 * Go to the end of the first fence, and check for any ` ~ characters after that. */
	if (text.length >= 3) {
		size_t i = 3;
		while (i < text.length && (text[i] == '`' || text[i] == '~')) {
			i++;
		}
		if (i < text.length) {
			while (i < text.length) {
				if (text[i] == '`' || text[i] == '~') {
					return false;
				}
				i++;
			}
		}
	}

	return true;
}

private string getHtmlTagName(string ln) {
	return parseHtmlBlockLine(ln).tagName;
}

private bool isLineIndented(string ln) {
	return ln.startsWith("\t") || ln.startsWith("    ");
}

private string unindentLine(string ln) {
	if (ln.startsWith("\t")) return ln[1 .. $];
	if (ln.startsWith("    ")) return ln[4 .. $];
	assert(false);
}

private int parseEmphasis(ref string str, ref string text) {
	string pstr = str;
	if (pstr.length < 3) return false;

	string ctag;
	if (pstr.startsWith("***")) ctag = "***";
	else if (pstr.startsWith("**")) ctag = "**";
	else if (pstr.startsWith("*")) ctag = "*";
	else if (pstr.startsWith("___")) ctag = "___";
	else if (pstr.startsWith("__")) ctag = "__";
	else if (pstr.startsWith("_")) ctag = "_";
	else return false;

	pstr = pstr[ctag.length .. $];

	/* If the first character is whitespace,
	 * this can't be a left-flanking delimiter run. */
	if (isWhite(pstr[0])) return false;

	ptrdiff_t cidx() { return pstr.indexOf(ctag); }
	if (cidx() < 1) return false;

	text = pstr[0 .. cast(size_t)cidx()];

	str = pstr[cast(size_t)cidx()+ctag.length .. $];
	return cast(int)ctag.length;
}

private bool parseStrike(ref string str, ref string strucken) {
	string pstr = str;
	if (pstr.length < 5) {
		return false;
	}
	if (!pstr.startsWith("~~")) {
		return false;
	}
	pstr = pstr[2 .. $];
	ptrdiff_t cidx() { return pstr.indexOf("~~"); }
	if (cidx() < 1) {
		return false;
	}

	strucken = pstr[0 .. cast(size_t)cidx()];
	str = pstr[cast(size_t)cidx()+2 .. $];
	return true;
}

private bool parseInlineCode(ref string str, ref string code) {
	string pstr = str;
	if (pstr.length < 3 || pstr[0] != '`') return false;
	string ctag;
	size_t i;
	while (pstr[i] == '`') {
		i++;
	}
	ctag = pstr[0 .. i];
	pstr = pstr[ctag.length .. $];

	ptrdiff_t cidx() { return pstr.indexOf(ctag); }
	if (cidx() < 1) return false;

	code = pstr[0 .. cast(size_t)cidx()].strip();
	str = pstr[cast(size_t)cidx()+ctag.length .. $];
	return true;
}

private bool parseLink(ref string str, ref Link dst, LinkRefs linkrefs) {
	string pstr = str;
	if (pstr.length < 3) return false;
	// ignore img-link prefix
	if (pstr[0] == '!') pstr = pstr[1 .. $];

	// parse the text part [text]
	if (pstr[0] != '[') return false;
	auto cidx = pstr.matchBracket();
	if (cidx < 1) return false;
	string refid;
	dst.text = pstr[1 .. cidx];
	pstr = pstr[cidx+1 .. $];

	// parse either (link '['"title"']') or '[' ']'[refid]
	if (pstr.length > 2 && pstr[0] == '(') {
		cidx = pstr.matchBracket();
		if (cidx < 1) return false;
		auto inner = pstr[1 .. cidx];
		immutable qidx = inner.indexOf('"');
		if (qidx > 1 && inner[qidx - 1].isWhite()) {
			dst.url = inner[0 .. qidx].stripRight();
			immutable len = inner[qidx .. $].lastIndexOf('"');
			if (len == 0) return false;
			assert(len > 0);
			dst.title = inner[qidx + 1 .. qidx + len];
		} else {
			dst.url = inner.stripRight();
			dst.title = null;
		}
		if (dst.url.startsWith("<") && dst.url.endsWith(">"))
			dst.url = dst.url[1 .. $-1];
		pstr = pstr[cidx+1 .. $];
	} else if (dst.text.length > 0) {
		refid = dst.text;
	} else {
		if (pstr.length < 2) return false;
		if (pstr[0] == ' ') pstr = pstr[1 .. $];
		if (pstr[0] != '[') return false;
		pstr = pstr[1 .. $];
		cidx = pstr.lastIndexOf(']');
		if (cidx < 0) return false;
		if (cidx == 0) refid = dst.text;
		else refid = pstr[0 .. cidx];
		pstr = pstr[cidx+1 .. $];
	}

	if (refid.length > 0) {
		auto pr = toLower(refid) in linkrefs.ret;
		if (pr is null) {
			return false;
		}
		dst.url = pr.url;
		dst.title = pr.title;
	}

	str = pstr;
	return true;
}

private bool parseAutoLink(ref string str, ref string url) {
	string pstr = str;
	if (pstr.length < 3) return false;
	if (pstr[0] != '<') return false;
	pstr = pstr[1 .. $];
	auto cidx = pstr.indexOf('>');
	if (cidx < 0) return false;
	url = pstr[0 .. cidx];
	if (anyOf(url, " \t")) return false;
	if (!anyOf(url, ":@")) return false;
	str = pstr[cidx+1 .. $];
	if (url.indexOf('@') > 0) url = "mailto:"~url;
	return true;
}

private string urlEscape(string s, bool escapeSpaces, bool escapeSlashes)
{
	StringSink ss;
	foreach (dchar c; s) {
		switch (c) {
		default:
			string sss = encode(c);
			foreach (char cc; sss) {
				uint i = cast(uint) cc;
				if (i <= 127) {
					ss.sink(encode(cc));
				} else {
					ss.sink("%");
					ss.sink(format("%X", i));
				}
			}
			continue;
		case ' ':
			if (!escapeSpaces) {
				goto default;
			}
			ss.sink("%20");
			break;
		case '\\':
			if (!escapeSlashes) {
				goto default;
			}
			ss.sink("%5C");
			break;
		}
	}
	return ss.toString();
}

private class LinkRefs
{
	LinkRef[string] ret;

	void scanForReferences(ref string[] lines) {
		bool[size_t] reflines;
		bool lookingForUrl, lookingForTitle;
		string currentRefid, currentUrl;
		size_t[] multilines;
		char titleChar = '?';
		char[] titleBuf;
		size_t startidx;  // The index this ref started parsing on.
		string[size_t] insertlines;

		void resetVars()
		{
			currentUrl = currentRefid = "";
			multilines = [];
			lookingForTitle = lookingForUrl = false;
			titleBuf = [];
			titleChar = '?';
		}

		// search for reference definitions:
		//   [refid] link "opt text"
		//   [refid] <link> "opt text"
		//   "opt text", 'opt text', (opt text)
		size_t lnidx;
		while (lnidx < lines.length) {
			auto leadingSpaces = countLeading(lines[lnidx], ' ');
			string ln = stripLeft(lines[lnidx]);
			if (!ln.startsWith("[") && !lookingForUrl && !lookingForTitle) {
				auto starti = ln.indexOf("[");
				auto cdatai = ln.indexOf("<![CDATA[");
				if (starti < 0 || cdatai >= 0) {
					lnidx++;
					continue;
				}
				if (starti > 0) {
					insertlines[lnidx] = ln[0 .. starti];
					ln = ln[starti .. $];
				}
			}

			if (!lookingForUrl && !lookingForTitle && lnidx > 0) {
				auto p = (lnidx-1) in reflines;
				string dummy;
				if (!lines[lnidx-1].stripLeft().startsWith("[") &&
				    !isAtxHeaderLine(lines[lnidx-1], leadingSpaces) &&
					!isHlineLine(ln, leadingSpaces) &&
					!isOListLine(ln, ref dummy) && !isUListLine(ln) &&
					!isLineBlank(lines[lnidx-1]) &&
					p is null) {
					lnidx++;
					continue;
				}
			}

			if (leadingSpaces >= 4 && !lookingForUrl && !lookingForTitle) {
				lnidx++;
				continue;
			}

			ln = strip(ln);
			if (!ln.startsWith("[") && !lookingForUrl && !lookingForTitle) {
				lnidx++;
				continue;
			}

			if (!lookingForUrl && !lookingForTitle) {
				startidx = lnidx;
				ln = ln[1 .. $];
				ptrdiff_t idx() {
					return ln.indexOf("]:");
				}
				string refid;
				if (idx() < 0) {
					if (ln.indexOf("]") >= 0) {
						lnidx++;
						continue;
					}
					size_t[] indices;
					do {
						indices ~= lnidx;
						lnidx++;
						ln = strip(lines[lnidx]);
						if (ln.indexOf("]") < 0) {
							refid ~= ln;
						}
					} while (lnidx < lines.length - 1 && ln.indexOf("]") < 0);
					if (ln.startsWith("]:")) {
						foreach (index; indices) {
							reflines[index] = true;
							reflines[lnidx] = true;
						}
						continue;
					}
				} else {
					refid = ln[0 .. cast(size_t)idx()];
					ln = stripLeft(ln[cast(size_t)idx()+2 .. $]);
				}
				currentRefid = refid;
			} else {
				ln = stripLeft(ln);
			}

			string url;
			if (!lookingForTitle) {
				if (ln.startsWith("<")) {
					auto i = ln.indexOf('>');
					if (i < 0) {
						lnidx++;
						continue;
					}
					url = ln[1 .. cast(size_t)i];
					ln = ln[cast(size_t)i+1 .. $];
				} else {
					auto i = ln.indexOf(' ');
					if (i > 0) {
						url = ln[0 .. cast(size_t)i];
						ln = ln[cast(size_t)i+1 .. $];
					} else {
						i = ln.indexOf('\t');
						if (i < 0) {
							url = ln;
							ln = ln[$ .. $];
						} else {
							url = ln[0 .. cast(size_t)i];
							ln = ln[cast(size_t)i+1 .. $];
						}
					}
				}
				if (strip(url).length == 0) {
					if (lookingForUrl) {
						resetVars();
						lnidx++;
						continue;
					}
					lookingForUrl = true;
					multilines ~= lnidx;
					lnidx++;
					continue;
				} else {
					currentUrl = url;
				}
			}
			ln = stripLeft(ln);

			if (ln.length >= 1 && titleChar == '?') {
				if (ln[0] == '(' || ln[0] == '\"' || ln[0] == '\'') {
					lookingForTitle = true;
					titleChar = ln[0];
					titleBuf = [];
					auto endi = ln.lastIndexOf(titleChar);
					ln = ln[1 .. $];
					if (ln.length == 0 || ln.stripRight()[$-1] != titleChar) {
						if (endi != 0) {
							title = "";
							lookingForTitle = false;
						} else {
							titleBuf ~= ln ~ '\n';
							multilines ~= lnidx;
							lnidx++;
							continue;
						}
					}
				}
			}
			if (titleChar == '?' && !lookingForTitle) {
				lookingForTitle = true;
				multilines ~= lnidx;
				if (lnidx < lines.length - 1 && lines[lnidx+1].stripLeft()[0] != '[') {
					lnidx++;
					continue;
				}
			}

			if (titleChar == '?' && lookingForTitle) {
				title = "";
				lookingForTitle = false;
			}

			string title;
			auto stripped = ln.stripRight();
			if (stripped.length >= 1 && stripped[$-1] == titleChar) {
				titleBuf ~= stripped[0 .. $-1];
				title = cast(string)titleBuf;
				ln = "";
			} else if (lookingForTitle) {
				if (strip(ln).length != 0) {
					titleBuf ~= ln ~ '\n';
					multilines ~= lnidx;
					lnidx++;
					continue;
				}
				if (titleBuf.length > 0) {
					resetVars();
					lnidx++;
					continue;
				} else {
					title = "";
				}
			}

			if (strip(ln).length > 0 && startidx == lnidx) {
				/* CommonMark can't make up its mind on whether newlines are
				 * just whitespace or treated differently. In this case, the
				 * main description of link references and the examples don't
				 * match up.
				 *
				 * This catches `[foo]: /url "title" ok` and invalidates the line.
				 * If there's a newline after the url, only the title is invalidated.
				 */
				resetVars();
				lnidx++;
				continue;
			}

			currentUrl = urlEscape(backslashEscape(currentUrl), true, true);
			title = backslashEscape(title);
			LinkRef lr = {currentRefid, currentUrl, title};
			auto id = toLower(currentRefid);
			auto tag = id in ret;
			if (tag is null) {
				ret[toLower(currentRefid)] = lr;
			}
			if (lookingForTitle) {
				multilines ~= lnidx;
			}
			foreach (i; multilines) {
				reflines[i] = true;
			}
			resetVars();
			lnidx++;
		}

		// remove all lines containing references
		string[] nonreflines;
		foreach (i, ln; lines) {
			auto p = i in reflines;
			auto pp = i in insertlines;
			if (p is null) {
				nonreflines ~= ln;
			} else if (pp !is null) {
				nonreflines ~= *pp;
			}
		}
		lines = nonreflines;
	}
}

private struct LinkRef {
	string id;
	string url;
	string title;
}

private struct Link {
	string text;
	string url;
	string title;
}
